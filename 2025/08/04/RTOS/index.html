<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="操作系统介绍什么是裸机开发裸机开发指的是在没有操作系统（OS）或者其他高级软件支持的情况下，直接在裸机硬件上进行软件开发的过程。在裸机开发中，开发者需要直接面对硬件层面的操作和控制，亲自管理 CPU、内存以及 I&#x2F;O 资源，而不依赖于任何操作系统提供的抽象层或者服务。 我们前面学习的 STM32 单片机代码都属于裸机开发。">
<meta property="og:type" content="article">
<meta property="og:title" content="RTOS学习笔记（From尚硅谷）">
<meta property="og:url" content="http://example.com/2025/08/04/RTOS/index.html">
<meta property="og:site_name" content="CYZ的个人博客">
<meta property="og:description" content="操作系统介绍什么是裸机开发裸机开发指的是在没有操作系统（OS）或者其他高级软件支持的情况下，直接在裸机硬件上进行软件开发的过程。在裸机开发中，开发者需要直接面对硬件层面的操作和控制，亲自管理 CPU、内存以及 I&#x2F;O 资源，而不依赖于任何操作系统提供的抽象层或者服务。 我们前面学习的 STM32 单片机代码都属于裸机开发。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2025/08/04/RTOS/image1.png">
<meta property="og:image" content="http://example.com/2025/08/04/RTOS/image2.png">
<meta property="og:image" content="http://example.com/2025/08/04/RTOS/image3.png">
<meta property="og:image" content="http://example.com/2025/08/04/RTOS/image4.png">
<meta property="og:image" content="http://example.com/2025/08/04/RTOS/image5.png">
<meta property="og:image" content="http://example.com/2025/08/04/RTOS/image6.png">
<meta property="og:image" content="http://example.com/2025/08/04/RTOS/image7.png">
<meta property="og:image" content="http://example.com/2025/08/04/RTOS/image8.png">
<meta property="article:published_time" content="2025-08-04T08:04:49.000Z">
<meta property="article:modified_time" content="2025-08-04T10:52:16.000Z">
<meta property="article:author" content="CYZ">
<meta property="article:tag" content="操作系统，RTOS，嵌入式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/08/04/RTOS/image1.png">

<link rel="canonical" href="http://example.com/2025/08/04/RTOS/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>RTOS学习笔记（From尚硅谷） | CYZ的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CYZ的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/04/RTOS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/chino2.jpg">
      <meta itemprop="name" content="CYZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CYZ的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RTOS学习笔记（From尚硅谷）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-08-04 16:04:49 / 修改时间：18:52:16" itemprop="dateCreated datePublished" datetime="2025-08-04T16:04:49+08:00">2025-08-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="操作系统介绍"><a href="#操作系统介绍" class="headerlink" title="操作系统介绍"></a>操作系统介绍</h1><h2 id="什么是裸机开发"><a href="#什么是裸机开发" class="headerlink" title="什么是裸机开发"></a>什么是裸机开发</h2><p>裸机开发指的是在没有操作系统（OS）或者其他高级软件支持的情况下，直接在裸机硬件上进行软件开发的过程。在裸机开发中，开发者需要直接面对硬件层面的操作和控制，亲自管理 CPU、内存以及 I&#x2F;O 资源，而不依赖于任何操作系统提供的抽象层或者服务。</p>
<p>我们前面学习的 STM32 单片机代码都属于裸机开发。</p>
<span id="more"></span>

<h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><p>一个计算机系统可以大致分为三个部分：硬件（Hardware），操作系统（operating<br>system），应用程序（application programs）。</p>
<ol>
<li><p>硬件包含了芯片，存储空间，输入输出等设备为整个系统提供了基础的计算资源。</p>
</li>
<li><p>操作系统是一个控制程序，作为硬件和应用程序之间的桥梁，主要是和硬件打交道，负责协调分配计算资源和内存资源给不同的应用程序使用，并防止系统出现故障。面对来自不同应用程序的大量且互相竞争的资源请求，操作系统通过一个调度算法和内存管理算法尽可能把资源公平且有效率地分配给不同的程序。</p>
</li>
<li><p>应用程序则通过调用操作系统提供的 API 接口获得相应资源完成指定的任务。</p>
</li>
</ol>
<p>操作系统从整体上分为两大类:<strong>通用操作系统</strong>和<strong>实时操作系统</strong>。</p>
<h3 id="通用操作系统"><a href="#通用操作系统" class="headerlink" title="通用操作系统"></a>通用操作系统</h3><p>通用操作系统包括 Linux，Windows，MACOS 等主流的操作系统。这些操作系统大家每天都在使用，功能也十分强大，只是它们有时为了保障系统的流畅运行，就不能保证每个程序都能实时响应，在易用性和实时性之间有所取舍。而且单片机有限的片上资源也不足以支撑通用操作系统的运行。</p>
<h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p>实时操作系统（RTOS-Real Time Operating System）中实时（Real<br>Time）指的是任务（Task）或者说实现一个功能的线程（Thread）必须在给定的时间(Deadline)内完成。</p>
<p>为了保障这些实时任务能在给定的时间内完成，需要一个实时系统对这些任务进行调度和管理。一个实时操作系统能尽力保障每个任务的运行时间在规定时间内完成，这包括</p>
<ol start="4">
<li><p>对中断和内部异常的处理</p>
</li>
<li><p>对安全相关的事件的处理</p>
</li>
<li><p>任务调度机制等</p>
</li>
</ol>
<p>正所谓术业有专攻，在嵌入式领域中，嵌入式实时操作系统(RTOS)可以更合理、更有效地利用 CPU 的资源，简化应用软件的设计，缩短系统开发时间，从而更好地保证系统的实时性和可靠性。</p>
<p>目前比较流行的实时操作系统包括黑莓 QNX，<strong>FreeRTOS</strong>，uCOS，RT-Thread 等</p>
<h2 id="FreeRTOS-简介"><a href="#FreeRTOS-简介" class="headerlink" title="FreeRTOS 简介"></a>FreeRTOS 简介</h2><p>RTOS(实时操作系统)是指一类系统，如 FreeRTOS，uC&#x2F;OS，RTX，RT-Thread<br>等，都是 RTOS 类操作系统。</p>
<p>FreeRTOS 是所有实时操作系统中最受欢迎的一款.</p>
<h3 id="FreeRTOS-发展历史"><a href="#FreeRTOS-发展历史" class="headerlink" title="FreeRTOS 发展历史"></a>FreeRTOS 发展历史</h3><p>FreeRTOS 由美国的 Richard Barry 于 2003 年发布。</p>
<p>FreeRTOS 于 2017 年被亚马逊收购，改名为 AWS FreeRTOS。</p>
<h3 id="FreeRTOS-优势"><a href="#FreeRTOS-优势" class="headerlink" title="FreeRTOS 优势"></a>FreeRTOS 优势</h3><p>FreeRTOS 是市场领先的面向微控制器和小型微处理器的实时操作系统<br>(RTOS)，与世界领先的芯片公司合作开发，现在每 170 秒下载一次。</p>
<p>FreeRTOS 通过 MIT 开源许可免费分发，包括一个内核和一组不断丰富的 IoT<br>库，适用于<strong>所有行业领域</strong>。FreeRTOS 的构建突出<strong>可靠性和易用性</strong>。</p>
<p>FreeRTOS 是一款受欢迎、广泛应用于嵌入式系统的 RTOS，其开源、轻量级、可移植的特点使其成为许多嵌入式开发者的首选，主要优势如下：</p>
<ul>
<li><p>开源和免费：FreeRTOS 是一款开源的 RTOS，采用 MIT 许可证发布，可以免费使用、修改和分发。</p>
</li>
<li><p>轻量级设计：FreeRTOS 注重轻量级设计，适用于资源受限的嵌入式系统，不占用过多内存和处理器资源。</p>
</li>
<li><p>广泛应用：FreeRTOS 在嵌入式领域得到广泛应用，包括工业自动化、医疗设备、消费电子产品、汽车电子等。</p>
</li>
<li><p>多平台支持：FreeRTOS 的设计注重可移植性，可以轻松地移植到不同的硬件平台，支持多种处理器架构。</p>
</li>
<li><p>丰富的功能：提供了多任务调度、任务通信、同步等功能，适用于复杂的嵌入式应用场景。</p>
</li>
</ul>
<h3 id="FreeRTOS-特点"><a href="#FreeRTOS-特点" class="headerlink" title="FreeRTOS 特点"></a>FreeRTOS 特点</h3><p>官网：<a target="_blank" rel="noopener" href="https://freertos.org/">https://freertos.org/</a>，并且支持中文。</p>
<ul>
<li><p>任务调度：FreeRTOS 通过任务调度器管理多个任务，支持不同优先级的任务，实现任务的有序执行。</p>
</li>
<li><p>任务通信和同步：提供了队列、信号量等机制，支持任务之间的通信和同步，确保数据的安全传递。</p>
</li>
<li><p>内存管理：提供简单的内存管理机制，适用于嵌入式环境，有效利用有限的内存资源。</p>
</li>
<li><p>定时器和中断处理：支持定时器功能，能够处理中断，提供了可靠的实时性能。</p>
</li>
<li><p>开发社区：拥有庞大的用户社区，开发者可以在社区中获取支持、解决问题，并分享经验。</p>
</li>
<li><p>可移植性：设计注重可移植性，可以轻松地移植到不同的硬件平台，提高了代码的重用性。</p>
</li>
</ul>
<h1 id="FreeRTOS-基础知识"><a href="#FreeRTOS-基础知识" class="headerlink" title="FreeRTOS 基础知识"></a>FreeRTOS 基础知识</h1><h2 id="多任务处理"><a href="#多任务处理" class="headerlink" title="多任务处理"></a>多任务处理</h2><p><strong>内核</strong>是操作系统的核心组件。诸如 Linux 这样的操作系统采用的内核，<br>看似允许用户同时访问计算机。很明显，<strong>多个用户可以同时执行多个程序</strong> 。</p>
<p>每个执行程序都是受操作系统控制的任务（或线程）。如果一个操作系统能够以这种方式执行多个任务，<br>则可称其为<strong>多任务操作系统</strong>。</p>
<p>使用多任务操作系统可以<strong>简化</strong>原本<strong>复杂</strong>的软件应用程序的<strong>设计</strong> ：</p>
<ol>
<li><p>操作系统的多任务处理和任务间通信功能允许将复杂的应用程序分割成一组更小、更易于管理的任务。</p>
</li>
<li><p>通过分割，您可以更轻松地执行软件测试、分解团队内部工作以及复用代码。</p>
</li>
<li><p>复杂的时序和排序细节可以从应用程序代码中移除，由操作系统负责。</p>
</li>
</ol>
<p>即使单核处理器一次只能执行一项任务。<br>多任务操作系统可以通过任务之间的快速切换制造并发执行的假象。下图展示了与时间相关的三项任务的执行模式。<br>任务名称采用颜色编码，并写在左手边。 时间从左向右移动，<br>彩色线条显示了在任何特定时间正在执行的任务。<br>上方展示了所感知的并发执行模式， 下方展示了实际的多任务执行模式。</p>
<img src="/2025/08/04/RTOS/image1.png" class="" title="不同执行模式">

<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>一个处理器核心在某一时刻只能运行一个任务，如在各个任务之间迅速切换，这样看起来就像多个任务在同时运行。操作系统中任务调度器的责任就是决定在某一时刻要执行哪个任务。</p>
<p>调度器是内核中负责决定在任何特定时间应执行哪些任务的部分。内核可以在任务生命周期内多次挂起并且稍后恢复一个任务。</p>
<p>调度策略是调度器用来决定在任何时间点执行哪个任务的算法。</p>
<p>FreeRTOS<br>默认使用<strong>固定优先级</strong>的<strong>抢占式调度策略</strong>，对<strong>同等优先级</strong>的任务执行<strong>时间片轮询</strong>调度：</p>
<ul>
<li><p>抢占式调度：FreeRTOS 采用抢占式调度方式，允许更高优先级的任务在任何时刻抢占正在执行的低优先级任务。这确保了高优先级任务能够及时响应，并提高了系统的实时性。</p>
</li>
<li><p>时间片轮询：在相同优先级的任务之间，FreeRTOS 采用时间片轮转策略。每个任务执行一个时间片，如果有其他同优先级的任务等待执行，则切换到下一个任务。这有助于公平地分配 CPU 时间。</p>
</li>
</ul>
<p>但是并不是说高优先级的任务会一直执行，导致低优先级的任务无法得到执行。如果高优先级任务**等待某个资源（延时或等待信号量等）**而无法执行，调度器会选择执行其他就绪的高优先级的任务。</p>
<h2 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h2><p>FreeRTOS 中任务共存在 4 种状态：</p>
<ul>
<li><p>运行态：当任务实际执行时，它被称为处于运行状态。如果运行 RTOS<br>的处理器只有一个内核，<br>那么在任何给定时间内都只能有一个任务处于运行状态。注意在 STM32 中，同一时间仅一个任务处于运行态。</p>
</li>
<li><p>就绪态：准备就绪任务指那些能够执行（它们不处于阻塞或挂起状态），<br>但目前没有执行的任务，<br>因为同等或更高优先级的不同任务已经处于运行状态。</p>
</li>
<li><p>阻塞态：如果任务当前正在等待延时或外部事件，则该任务被认为处于阻塞状态。</p>
</li>
<li><p>挂起态：类似暂停，调用函数 vTaskSuspend()<br>进入挂起态，需要调用解挂函数 vTaskResume()才可以进入就绪态。</p>
</li>
</ul>
<p>只有就绪态可转变成运行态，其他状态的任务想运行，必须先转变成就绪态。转换关系如下：</p>
<img src="/2025/08/04/RTOS/image2.png" class="" title="不同状态转换">

<p>这四种状态中，除了运行态，其他三种任务状态的任务都有其对应的任务状态列表：</p>
<ul>
<li><p>就绪列表：pxReadyTasksLists[x]，其中 x 代表任务优先级数值。</p>
</li>
<li><p>阻塞列表：pxDelayedTaskList。</p>
</li>
<li><p>挂起列表：xSuspendedTaskList。</p>
</li>
</ul>
<p>列表类似于链表，后面章节会专门介绍。</p>
<p>以就绪列表为例。如果在 32 位的硬件中，会保存一个 32 位的变量，代表 0-31 的优先级。当某个位，置一时，代表所对应的优先级就绪列表有任务存在。</p>
<img src="/2025/08/04/RTOS/image3.png" class="" title="就绪列表">

<p>如果有多个任务优先级相同，会连接在同一个就绪列表上：</p>
<img src="/2025/08/04/RTOS/image4.png" class="" title="就绪列表">
<p>调度器总是在所有处于就绪列表的任务中，选择具有最高优先级的任务来执行。</p>
<h2 id="FreeRTOS-的滴答"><a href="#FreeRTOS-的滴答" class="headerlink" title="FreeRTOS 的滴答"></a>FreeRTOS 的滴答</h2><p>休眠时，RTOS 任务将指定需要”唤醒”的时间。 阻塞时，RTOS<br>任务可以指定希望等待的最长时间。</p>
<p>FreeRTOS 实时内核通过<strong>滴答计数变量</strong>测量时间。定时器中断（RTOS<br>滴答中断）以严格的时间精度增加滴答数——允许实时内核以所选择的定时器<strong>中断频率</strong>的分辨率来测量时间。</p>
<p>每次滴答数增加时，实时内核必须检查是否现在是解除阻塞或唤醒任务的时间。在滴答<br>ISR 期间唤醒或解除阻塞的任务的优先级可能高于被中断任务的优先级。</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><ol>
<li>什么上下文切换</li>
</ol>
<p>当一个任务执行时，它会利用处理器&#x2F;微控制器寄存器，并像其他程序一样访问<br>RAM 和<br>ROM。这些资源（处理器寄存器，堆栈等）一起组成了任务执行<strong>上下文</strong>。</p>
<p>一个任务是一段有顺序的代码——它不知道什么时候会被内核挂起（换出或换入）或恢复（换入或换入），<br>甚至不知道什么时候自己被挂起或恢复过。</p>
<p>一个任务在即将执行将两个处理器寄存器内包含的数值相加之前被挂起。<br>当该任务被挂起时，其他任务会执行，还可能会修改处理器寄存器的数值。恢复时，<br>该任务不会知道处理器寄存器已经被修改过了——如果它使用经修改过的数值，<br>那么求和会得到一个错误的数值。</p>
<p>为了防止这种类型的错误，<strong>任务</strong>在<strong>恢复时</strong>必须有一个与<strong>挂起之前相同的上下文</strong><br>。通过在任务挂起时保存任务的上下文，操作系统内核负责确保上下文保持不变。任务恢复时，其保存的上下文在执行之前由操作系统内核恢复。</p>
<p>保存被挂起的任务的上下文和恢复被恢复的任务的上下文的过程被称为<br><strong>上下文切换</strong>。</p>
<ol>
<li>将 TaskA 在相应的处理器寄存器中的上下文保存到其任务堆栈中。</li>
</ol>
<img src="/2025/08/04/RTOS/image5.png" class="" title="不同执行模式">

<ol start="2">
<li>将 TaskB 的上下文从其任务堆栈中恢复到相应的处理器寄存器中</li>
</ol>
<img src="/2025/08/04/RTOS/image6.png" class="" title="不同执行模式">

<ol start="2">
<li>什么时候进行上下文切换</li>
</ol>
<p>在需要切换任务的时候进行上下文切换，真正执行上下文切换是在 PendSV 的 ISR 中处理的。使用 PendSV 是因为其可以手动触发，并且可以在其他更高中断优先级的 ISR 中来进行设置，比较灵活。具体触发操作是将中断控制和状态寄存器<br>ICSR 的 bit28，也就是 PendSV 的挂起位置 1 来触发 PendSV<br>中断。FreeRTOS 会将 PendSV 设置为最低中断优先级，避免任务切换影响到其他正常的 ISR。</p>
<p>在 FreeRTOS 中有以下几个情况会触发 PendSV 异常产生切换：</p>
<ol>
<li><p><strong>RTOS<br>滴答中断</strong>：会处理就绪列表，判断是否要切换任务（包括抢占式、时间片轮转）。</p>
</li>
<li><p><strong>任务执行完毕</strong>：主动调用任务切换函数进行强制切换。</p>
</li>
</ol>
<h2 id="空闲任务"><a href="#空闲任务" class="headerlink" title="空闲任务"></a>空闲任务</h2><p>RTOS<br>调度器启动时，<strong>自动创建空闲任务</strong>，以确保始终存在一个能够运行的任务。</p>
<p>空闲以最低优先级创建，以确保如果有更高的优先级应用程序任务处于准备就绪状态，空闲任务则不使用任何<br>CPU 时间。</p>
<p>空闲任务负责释放被删除的任务的内存。</p>
<h1 id="FreeRTOS-移植"><a href="#FreeRTOS-移植" class="headerlink" title="FreeRTOS 移植"></a>FreeRTOS 移植</h1><h2 id="FreeRTOS-源码结构介绍"><a href="#FreeRTOS-源码结构介绍" class="headerlink" title="FreeRTOS 源码结构介绍"></a>FreeRTOS 源码结构介绍</h2><h3 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h3><ol start="3">
<li>官网下载</li>
</ol>
<p>官网地址：<a target="_blank" rel="noopener" href="https://www.freertos.org/">https://www.freertos.org/</a></p>
<ol start="4">
<li>Github 下载</li>
</ol>
<p>Github 地址：<a target="_blank" rel="noopener" href="https://github.com/FreeRTOS/FreeRTOS/releases">https://github.com/FreeRTOS/FreeRTOS/releases</a></p>
<h3 id="源码结构介绍"><a href="#源码结构介绍" class="headerlink" title="源码结构介绍"></a>源码结构介绍</h3><ol>
<li>源码整体结构</li>
</ol>
<hr>
<p>名称 描述</p>
<hr>
<p>FreeRTOS FreeRTOS 内核</p>
<p>FreeRTOS-Plus FreeRTOS 组件，一般我们会选择使用第三方的组件</p>
<p>tools 工具</p>
<p>GitHub-FreeRTOS-Home FreeRTOS 的 GitHub 仓库链接</p>
<p>Quick_Start_Guide 快速入门指南官方文档链接</p>
<p>Upgrading-to-FreeRTOS-xxx 升级到指定 FreeRTOS 版本官方文档链接</p>
<p>History.txt FreeRTOS 历史更新记录</p>
<p>其他 其他</p>
<hr>
<ol start="5">
<li>FreeRTOS 文件夹结构</li>
</ol>
<hr>
<p>名称 描述</p>
<hr>
<p>Demo FreeRTOS 演示例程，支持多种芯片架构、多种型号芯片</p>
<p>License FreeRTOS 相关许可</p>
<p>Source FreeRTOS 源码，最重要的文件夹</p>
<p>Test 公用以及移植层测试代码</p>
<hr>
<ol start="6">
<li>Source 文件夹结构如下</li>
</ol>
<hr>
<p>名称 描述</p>
<hr>
<p>include 内包含了 FreeRTOS 的头文件</p>
<p>portable 包含 FreeRTOS 移植文件：与编译器相关、keil 编译环境</p>
<p>croutine.c 协程相关文件</p>
<p>event_groups.c 事件相关文件</p>
<p>list.c 列表相关文件</p>
<p>queue.c 队列相关文件</p>
<p>stream_buffer.c 流式缓冲区相关文件</p>
<p>tasks.c 任务相关文件</p>
<p>timers.c 软件定时器相关文件</p>
<hr>
<p>include 文件夹和.c 文件是通用的头文件和 C<br>文件，这两部分的文件适用于各种编译器和处理器，是通用的。标红的是移植必需的，其他.c 文件根据需要选取。</p>
<p>portable 文件夹里根据编译器、内核等实际环境对应选取。</p>
<ol start="7">
<li>portable 文件夹结构</li>
</ol>
<p>FreeRTOS 操作系统归根到底是一个软件层面的东西，需要跟硬件联系在一起，portable 文件夹里面的东西就是连接桥梁。由于我们使用 MDK 开发，因此这里只重点介绍其中的部分移植文件。</p>
<hr>
<p>名称 描述</p>
<hr>
<p>Keil 指向 RVDS 文件夹</p>
<p>RVDS 不同内核芯片的移植文件</p>
<p>MemMang 内存管理相关文件</p>
<hr>
<p>Keil 文件夹里只有一个 See-also-the-RVDS-directory.txt，意思是让我们看 RVDS 文件夹。</p>
<ol>
<li>RVDS 文件夹</li>
</ol>
<p>RVDS 文件夹包含了各种处理器相关的文件夹，FreeRTOS<br>是一个软件，单片机是一个硬件，FreeRTOS<br>要想运行在一个单片机上面，它们就必须关联在一起。</p>
<p>关联还是得通过写代码来关联，这部分关联的文件叫接口文件，通常由汇编和 C<br>联合编写。这些接口文件都是跟硬件密切相关的，不同的硬件接口文件是不一样的，但都大同小异。编写这些接口文件的过程我们就叫移植，移植的过程通常由<br>FreeRTOS 和 mcu 原厂的人来负责，移植好的这些接口文件就放在 RVDS<br>这个文件夹的目录下。</p>
<p>FreeRTOS 为我们提供了 cortex-m0、m3、m4 和 m7<br>等内核的单片机的接口文件，根据 mcu 的内核选择对应的接口文件即可。其实准确来说，不能够叫移植，应该叫使用官方的移植，<br>因为这些跟硬件相关的接口文件，RTOS 官方都已经写好了，我们只是使用而已。</p>
<p>以 ARM_CM3 这个文件夹为例，里面只有”port.c”与”portmacro.h” 两个文件，</p>
<ul>
<li><p>port.c 文件：里面的内容是由 FreeRTOS 官方的技术人员为 Cortex-M3<br>内核的处理器写的接口文件，里面核心的上下文切换代码是由汇编语言编写而成，对技术员的要求比较高，我们只是使用的话只需拷贝过来用即可。</p>
</li>
<li><p>portmacro.h 文件：port.c 文件对应的头文件，主要是一些数据类型和宏定义。</p>
<ol>
<li>MemMang 文件夹</li>
</ol>
</li>
</ul>
<p>MemMang 文件夹下存放的是跟内存管理相关的，总共有五个 heap 文件以及一个<br>readme 说明文件。</p>
<p>这五个 heap 文件在移植的时候必须使用一个，因为 FreeRTOS<br>在创建内核对象的时候使用的是动态分配内存，而这些动态内存分配的函数则在这几个文件里面实现，不同的分配算法会导致不同的效率与结果，后面在内存管理中我们会讲解每个文件的区别，由于现在是初学，所以我们选用<br><strong>heap4.c</strong> 即可。</p>
<h2 id="FreeRTOS-在基于-HAL-库项目中移植步骤"><a href="#FreeRTOS-在基于-HAL-库项目中移植步骤" class="headerlink" title="FreeRTOS 在基于 HAL 库项目中移植步骤"></a>FreeRTOS 在基于 HAL 库项目中移植步骤</h2><h3 id="目录添加源码文件"><a href="#目录添加源码文件" class="headerlink" title="目录添加源码文件"></a>目录添加源码文件</h3><p>在例程的根路径下，新建”FreeRTOS”文件夹，并且在里面新建”portable”和”source”两个空文件夹。</p>
<p>拷贝 FreeRTOS 源码的 Source 文件夹的 7 个.c 文件到例程的 source 文件夹。</p>
<p>拷贝 FreeRTOS 源码 portable 文件夹下的 Keil、RVDS、MemMang 到例程的 portable 文件夹下。</p>
<p>其中例程的 MemMang 可只保留 heap_4.c:</p>
<p>其中例程的 RVDS 可只保留 ARM_CM3（对应我们的芯片内核）。</p>
<p>拷贝 FreeRTOS 源码 include 文件夹到例程的 FreeRTOS 文件夹下。</p>
<p>FreeRTOSConfig.h 文件是 FreeRTOS 的工程配置文件，因为 FreeRTOS<br>是可以裁剪的 实时操作内核，应用于不同的处理器平台，用户可以通过修改这个<br>FreeRTOS 内核的配置 头文件来裁剪 FreeRTOS<br>的功能，所以我们把它拷贝一份放在 user 这个文件夹下面。</p>
<p>在源码”..\FreeRTOS\Demo”文件夹下面找到 “ CORTEX_STM32F103_Keil “<br>这个文件夹下，找到 “FreeRTOSConfig.h”文件，然后拷贝到我们工程下的<br>“Core&#x2F;Inc” 文件夹下即可，等下我们需要对这个文件进行修改。</p>
<h3 id="工程添加源码文件"><a href="#工程添加源码文件" class="headerlink" title="工程添加源码文件"></a>工程添加源码文件</h3><p>工程新建 Group”FreeRTOS&#x2F;Source”和”FreeRTOS&#x2F;Portable”。</p>
<p>FreeRTOS&#x2F;Source 添加.c 文件。</p>
<p>FreeRTOS&#x2F;Portable 添加 port.c 和 heap_4.c 文件。</p>
<p>添加配置头文件。</p>
<p>添加头文件。</p>
<p>FreeRTOS<br>的源码已经添加到开发环境的组文件夹下面，编译的时候需要为这些源文件指定头文件的路径，不然编译会报错。FreeRTOS<br>的源码里面只有 include<br>和 RVDS\ARM_CM3 这两个文件夹下面有头文件，只需要将这两个头文件的路径在开发环境里面指定即可。</p>
<p>同时我们还将 FreeRTOSConfig.h 这个头文件拷贝到了工程根目录下的 Core&#x2F;Inc<br>文件夹下，这个路径本身就在开发环境里面。(放其他路径也可以,<br>就是一个.h 文件)</p>
<h3 id="系统配置文件修改"><a href="#系统配置文件修改" class="headerlink" title="系统配置文件修改"></a>系统配置文件修改</h3><p>FreeRTOSConfig.h 中添加如下 3 个配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define xPortPendSVHandler PendSV_Handler</span><br><span class="line"></span><br><span class="line">#define vPortSVCHandler SVC_Handler</span><br><span class="line"></span><br><span class="line">#define INCLUDE_xTaskGetSchedulerState 1</span><br></pre></td></tr></table></figure>

<h3 id="修改-stm32f1xx-it-c"><a href="#修改-stm32f1xx-it-c" class="headerlink" title="修改 stm32f1xx_it.c"></a>修改 stm32f1xx_it.c</h3><ol>
<li>引入头文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* USER CODE BEGIN Includes */</span><br><span class="line"></span><br><span class="line">#include &quot;FreeRTOS.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;task.h&quot;</span><br><span class="line"></span><br><span class="line">/* USER CODE END Includes */</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>注释掉 2 个函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// void SVC_Handler(void)</span><br><span class="line"></span><br><span class="line">// &#123;</span><br><span class="line"></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// void PendSV_Handler(void)</span><br><span class="line"></span><br><span class="line">// &#123;</span><br><span class="line"></span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加 SysTick 时钟中断服务函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* USER CODE BEGIN PV */</span><br><span class="line"></span><br><span class="line">extern void xPortSysTickHandler(void);</span><br><span class="line"></span><br><span class="line">/* USER CODE END PV */</span><br><span class="line"></span><br><span class="line">void SysTick_Handler(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN SysTick_IRQn 0 */</span><br><span class="line"></span><br><span class="line">    /* USER CODE END SysTick_IRQn 0 */</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN SysTick_IRQn 1 */</span><br><span class="line"></span><br><span class="line">    if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        xPortSysTickHandler();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* USER CODE END SysTick_IRQn 1 */</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：HAL 本身和 FreeRTOS 都默认依赖 SysTick，可能出现卡死的问题。</p>
<p>为了保险起见，可以考虑在 SYS 选择 HAL 时钟源的时候换成其他的，并且中断优先级设为较高。</p>
<h2 id="FreeRTOS-在基于寄存器项目中移植步骤"><a href="#FreeRTOS-在基于寄存器项目中移植步骤" class="headerlink" title="FreeRTOS 在基于寄存器项目中移植步骤"></a>FreeRTOS 在基于寄存器项目中移植步骤</h2><h3 id="目录添加源码文件-1"><a href="#目录添加源码文件-1" class="headerlink" title="目录添加源码文件"></a>目录添加源码文件</h3><p>在例程的根路径下，新建”FreeRTOS”文件夹，并且在里面新建”portable”和”source”两个空文件夹。</p>
<p>拷贝 FreeRTOS 源码的 Source 文件夹的 7 个.c 文件到例程的 source 文件夹。</p>
<p>拷贝 FreeRTOS 源码 portable 文件夹下的 Keil、RVDS、MemMang 到例程的 portable 文件夹下。</p>
<p>其中例程的 MemMang 可只保留 heap_4.c:</p>
<p>其中例程的 RVDS 可只保留 ARM_CM3（对应我们的芯片内核）。</p>
<p>拷贝 FreeRTOS 源码 include 文件夹到例程的 FreeRTOS 文件夹下。</p>
<p>FreeRTOSConfig.h 文件是 FreeRTOS 的工程配置文件，因为 FreeRTOS<br>是可以裁剪的 实时操作内核，应用于不同的处理器平台，用户可以通过修改这个<br>FreeRTOS 内核的配置头文件来裁剪 FreeRTOS<br>的功能，所以我们把它拷贝一份放在 user 这个文件夹下面。</p>
<h3 id="工程添加源码文件-1"><a href="#工程添加源码文件-1" class="headerlink" title="工程添加源码文件"></a>工程添加源码文件</h3><p>工程新建 Group”FreeRTOS&#x2F;Source”和”FreeRTOS&#x2F;Portable”。</p>
<h3 id="系统配置文件修改-1"><a href="#系统配置文件修改-1" class="headerlink" title="系统配置文件修改"></a>系统配置文件修改</h3><p>FreeRTOSConfig.h 中添加如下 3 个配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define xPortPendSVHandler PendSV_Handler</span><br><span class="line"></span><br><span class="line">#define vPortSVCHandler SVC_Handler</span><br><span class="line"></span><br><span class="line">#define INCLUDE_xTaskGetSchedulerState 1</span><br></pre></td></tr></table></figure>

<h3 id="main-c-中添加如下代码"><a href="#main-c-中添加如下代码" class="headerlink" title="main.c 中添加如下代码"></a>main.c 中添加如下代码</h3><p>FreeRTOS 使用滴答定时器来实现的系统时基,<br>需要实现滴答定时器的中断,并在中断中添加下面的代码.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extern void xPortSysTickHandler(void);</span><br><span class="line"></span><br><span class="line">void SysTick_Handler(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if(xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        xPortSysTickHandler();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="系统配置文件说明"><a href="#系统配置文件说明" class="headerlink" title="系统配置文件说明"></a>系统配置文件说明</h2><p>FreeRTOSConfig.h<br>配置文件作用：对 FreeRTOS 的功能进行配置和裁剪，以及 API 函数的使能等。</p>
<p>官网中文说明：<a target="_blank" rel="noopener" href="https://www.freertos.org/zh-cn-cmn-s/Documentation/02-Kernel/03-Supported-devices/02-Customization">https://www.freertos.org/zh-cn-cmn-s/Documentation/02-Kernel/03-Supported-devices/02-Customization</a></p>
<p>整体的配置项可以分为三类：</p>
<ul>
<li><p>INCLUDE 开头：一般是”INCLUDE_函数名”，函数的使能，1 表示可用，0 表示禁用。</p>
</li>
<li><p>config 开头：FreeRTOS 的一些功能配置，比如基本配置、内存配置、钩子配置、中断配置等。</p>
</li>
<li><p>其他配置：PendSV 宏定义、SVC 宏定义。</p>
</li>
</ul>
<p>根据需要去配置，后续章节的知识点和案例，会涉及到其中一些配置，再去熟悉即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#ifndef FREERTOS_CONFIG_H</span><br><span class="line">#define FREERTOS_CONFIG_H</span><br><span class="line"></span><br><span class="line">/* 头文件 */</span><br><span class="line">#include &quot;./SYSTEM/sys/sys.h&quot;</span><br><span class="line">#include &quot;./SYSTEM/usart/usart.h&quot;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">extern uint32_t SystemCoreClock;</span><br><span class="line"></span><br><span class="line">/* 基础配置项 */</span><br><span class="line">#define configUSE_PREEMPTION                            1                       /* 1: 抢占式调度器, 0: 协程式调度器, 无默认需定义 */</span><br><span class="line">#define configUSE_PORT_OPTIMISED_TASK_SELECTION         1                       /* 1: 使用硬件计算下一个要运行的任务, 0: 使用软件算法计算下一个要运行的任务, 默认: 0 */</span><br><span class="line">#define configUSE_TICKLESS_IDLE                         0                       /* 1: 使能tickless低功耗模式, 默认: 0 */</span><br><span class="line">#define configCPU_CLOCK_HZ                              SystemCoreClock         /* 定义CPU主频, 单位: Hz, 无默认需定义 */</span><br><span class="line">//#define configSYSTICK_CLOCK_HZ                          (configCPU_CLOCK_HZ / 8)/* 定义SysTick时钟频率，当SysTick时钟频率与内核时钟频率不同时才可以定义, 单位: Hz, 默认: 不定义 */</span><br><span class="line">#define configTICK_RATE_HZ                              1000                    /* 定义系统时钟节拍频率, 单位: Hz, 无默认需定义 */</span><br><span class="line">#define configMAX_PRIORITIES                            32                      /* 定义最大优先级数, 最大优先级=configMAX_PRIORITIES-1, 无默认需定义 */</span><br><span class="line">#define configMINIMAL_STACK_SIZE                        128                     /* 定义空闲任务的栈空间大小, 单位: Word, 无默认需定义 */</span><br><span class="line">#define configMAX_TASK_NAME_LEN                         16                      /* 定义任务名最大字符数, 默认: 16 */</span><br><span class="line">#define configUSE_16_BIT_TICKS                          0                       /* 1: 定义系统时钟节拍计数器的数据类型为16位无符号数, 无默认需定义 */</span><br><span class="line">#define configIDLE_SHOULD_YIELD                         1                       /* 1: 使能在抢占式调度下,同优先级的任务能抢占空闲任务, 默认: 1 */</span><br><span class="line">#define configUSE_TASK_NOTIFICATIONS                    1                       /* 1: 使能任务间直接的消息传递,包括信号量、事件标志组和消息邮箱, 默认: 1 */</span><br><span class="line">#define configTASK_NOTIFICATION_ARRAY_ENTRIES           1                       /* 定义任务通知数组的大小, 默认: 1 */</span><br><span class="line">#define configUSE_MUTEXES                               1                       /* 1: 使能互斥信号量, 默认: 0 */</span><br><span class="line">#define configUSE_RECURSIVE_MUTEXES                     1                       /* 1: 使能递归互斥信号量, 默认: 0 */</span><br><span class="line">#define configUSE_COUNTING_SEMAPHORES                   1                       /* 1: 使能计数信号量, 默认: 0 */</span><br><span class="line">#define configUSE_ALTERNATIVE_API                       0                       /* 已弃用!!! */</span><br><span class="line">#define configQUEUE_REGISTRY_SIZE                       8                       /* 定义可以注册的信号量和消息队列的个数, 默认: 0 */</span><br><span class="line">#define configUSE_QUEUE_SETS                            1                       /* 1: 使能队列集, 默认: 0 */</span><br><span class="line">#define configUSE_TIME_SLICING                          1                       /* 1: 使能时间片调度, 默认: 1 */</span><br><span class="line">#define configUSE_NEWLIB_REENTRANT                      0                       /* 1: 任务创建时分配Newlib的重入结构体, 默认: 0 */</span><br><span class="line">#define configENABLE_BACKWARD_COMPATIBILITY             0                       /* 1: 使能兼容老版本, 默认: 1 */</span><br><span class="line">#define configNUM_THREAD_LOCAL_STORAGE_POINTERS         0                       /* 定义线程本地存储指针的个数, 默认: 0 */</span><br><span class="line">#define configSTACK_DEPTH_TYPE                          uint16_t                /* 定义任务堆栈深度的数据类型, 默认: uint16_t */</span><br><span class="line">#define configMESSAGE_BUFFER_LENGTH_TYPE                size_t                  /* 定义消息缓冲区中消息长度的数据类型, 默认: size_t */</span><br><span class="line"></span><br><span class="line">/* 内存分配相关定义 */</span><br><span class="line">#define configSUPPORT_STATIC_ALLOCATION                 0                       /* 1: 支持静态申请内存, 默认: 0 */</span><br><span class="line">#define configSUPPORT_DYNAMIC_ALLOCATION                1                       /* 1: 支持动态申请内存, 默认: 1 */</span><br><span class="line">#define configTOTAL_HEAP_SIZE                           ((size_t)(10 * 1024))   /* FreeRTOS堆中可用的RAM总量, 单位: Byte, 无默认需定义 */</span><br><span class="line">#define configAPPLICATION_ALLOCATED_HEAP                0                       /* 1: 用户手动分配FreeRTOS内存堆(ucHeap), 默认: 0 */</span><br><span class="line">#define configSTACK_ALLOCATION_FROM_SEPARATE_HEAP       0                       /* 1: 用户自行实现任务创建时使用的内存申请与释放函数, 默认: 0 */</span><br><span class="line"></span><br><span class="line">/* 钩子函数相关定义 */</span><br><span class="line">#define configUSE_IDLE_HOOK                             0                       /* 1: 使能空闲任务钩子函数, 无默认需定义  */</span><br><span class="line">#define configUSE_TICK_HOOK                             0                       /* 1: 使能系统时钟节拍中断钩子函数, 无默认需定义 */</span><br><span class="line">#define configCHECK_FOR_STACK_OVERFLOW                  0                       /* 1: 使能栈溢出检测方法1, 2: 使能栈溢出检测方法2, 默认: 0 */</span><br><span class="line">#define configUSE_MALLOC_FAILED_HOOK                    0                       /* 1: 使能动态内存申请失败钩子函数, 默认: 0 */</span><br><span class="line">#define configUSE_DAEMON_TASK_STARTUP_HOOK              0                       /* 1: 使能定时器服务任务首次执行前的钩子函数, 默认: 0 */</span><br><span class="line"></span><br><span class="line">/* 运行时间和任务状态统计相关定义 */</span><br><span class="line">#define configGENERATE_RUN_TIME_STATS                   0                       /* 1: 使能任务运行时间统计功能, 默认: 0 */</span><br><span class="line">#if configGENERATE_RUN_TIME_STATS</span><br><span class="line">#include &quot;./BSP/TIMER/btim.h&quot;</span><br><span class="line">#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()        ConfigureTimeForRunTimeStats()</span><br><span class="line">extern uint32_t FreeRTOSRunTimeTicks;</span><br><span class="line">#define portGET_RUN_TIME_COUNTER_VALUE()                FreeRTOSRunTimeTicks</span><br><span class="line">#endif</span><br><span class="line">#define configUSE_TRACE_FACILITY                        1                       /* 1: 使能可视化跟踪调试, 默认: 0 */</span><br><span class="line">#define configUSE_STATS_FORMATTING_FUNCTIONS            1                       /* 1: configUSE_TRACE_FACILITY为1时，会编译vTaskList()和vTaskGetRunTimeStats()函数, 默认: 0 */</span><br><span class="line"></span><br><span class="line">/* 协程相关定义 */</span><br><span class="line">#define configUSE_CO_ROUTINES                           0                       /* 1: 启用协程, 默认: 0 */</span><br><span class="line">#define configMAX_CO_ROUTINE_PRIORITIES                 2                       /* 定义协程的最大优先级, 最大优先级=configMAX_CO_ROUTINE_PRIORITIES-1, 无默认configUSE_CO_ROUTINES为1时需定义 */</span><br><span class="line"></span><br><span class="line">/* 软件定时器相关定义 */</span><br><span class="line">#define configUSE_TIMERS                                1                               /* 1: 使能软件定时器, 默认: 0 */</span><br><span class="line">#define configTIMER_TASK_PRIORITY                       ( configMAX_PRIORITIES - 1 )    /* 定义软件定时器任务的优先级, 无默认configUSE_TIMERS为1时需定义 */</span><br><span class="line">#define configTIMER_QUEUE_LENGTH                        5                               /* 定义软件定时器命令队列的长度, 无默认configUSE_TIMERS为1时需定义 */</span><br><span class="line">#define configTIMER_TASK_STACK_DEPTH                    ( configMINIMAL_STACK_SIZE * 2) /* 定义软件定时器任务的栈空间大小, 无默认configUSE_TIMERS为1时需定义 */</span><br><span class="line"></span><br><span class="line">/* 可选函数, 1: 使能 */</span><br><span class="line">#define INCLUDE_vTaskPrioritySet                        1                       /* 设置任务优先级 */</span><br><span class="line">#define INCLUDE_uxTaskPriorityGet                       1                       /* 获取任务优先级 */</span><br><span class="line">#define INCLUDE_vTaskDelete                             1                       /* 删除任务 */</span><br><span class="line">#define INCLUDE_vTaskSuspend                            1                       /* 挂起任务 */</span><br><span class="line">#define INCLUDE_xResumeFromISR                          1                       /* 恢复在中断中挂起的任务 */</span><br><span class="line">#define INCLUDE_vTaskDelayUntil                         1                       /* 任务绝对延时 */</span><br><span class="line">#define INCLUDE_vTaskDelay                              1                       /* 任务延时 */</span><br><span class="line">#define INCLUDE_xTaskGetSchedulerState                  1                       /* 获取任务调度器状态 */</span><br><span class="line">#define INCLUDE_xTaskGetCurrentTaskHandle               1                       /* 获取当前任务的任务句柄 */</span><br><span class="line">#define INCLUDE_uxTaskGetStackHighWaterMark             1                       /* 获取任务堆栈历史剩余最小值 */</span><br><span class="line">#define INCLUDE_xTaskGetIdleTaskHandle                  1                       /* 获取空闲任务的任务句柄 */</span><br><span class="line">#define INCLUDE_eTaskGetState                           1                       /* 获取任务状态 */</span><br><span class="line">#define INCLUDE_xEventGroupSetBitFromISR                1                       /* 在中断中设置事件标志位 */</span><br><span class="line">#define INCLUDE_xTimerPendFunctionCall                  1                       /* 将函数的执行挂到定时器服务任务 */</span><br><span class="line">#define INCLUDE_xTaskAbortDelay                         1                       /* 中断任务延时 */</span><br><span class="line">#define INCLUDE_xTaskGetHandle                          1                       /* 通过任务名获取任务句柄 */</span><br><span class="line">#define INCLUDE_xTaskResumeFromISR                      1                       /* 恢复在中断中挂起的任务 */</span><br><span class="line"></span><br><span class="line">/* 中断嵌套行为配置 */</span><br><span class="line">#ifdef __NVIC_PRIO_BITS</span><br><span class="line">    #define configPRIO_BITS __NVIC_PRIO_BITS</span><br><span class="line">#else</span><br><span class="line">    #define configPRIO_BITS 4</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY         15                  /* 中断最低优先级 */</span><br><span class="line">#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY    5                   /* FreeRTOS可管理的最高中断优先级 */</span><br><span class="line">#define configKERNEL_INTERRUPT_PRIORITY                 ( configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )</span><br><span class="line">#define configMAX_SYSCALL_INTERRUPT_PRIORITY            ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )</span><br><span class="line">#define configMAX_API_CALL_INTERRUPT_PRIORITY           configMAX_SYSCALL_INTERRUPT_PRIORITY</span><br><span class="line"></span><br><span class="line">/* FreeRTOS中断服务函数相关定义 */</span><br><span class="line">#define xPortPendSVHandler                              PendSV_Handler</span><br><span class="line">#define vPortSVCHandler                                 SVC_Handler</span><br><span class="line"></span><br><span class="line">/* 断言 */</span><br><span class="line">#define vAssertCalled(char, int) printf(&quot;Error: %s, %d\r\n&quot;, char, int)</span><br><span class="line">#define configASSERT( x ) if( ( x ) == 0 ) vAssertCalled( __FILE__, __LINE__ )</span><br><span class="line"></span><br><span class="line">/* FreeRTOS MPU 特殊定义 */</span><br><span class="line">//#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0</span><br><span class="line">//#define configTOTAL_MPU_REGIONS                                8</span><br><span class="line">//#define configTEX_S_C_B_FLASH                                  0x07UL</span><br><span class="line">//#define configTEX_S_C_B_SRAM                                   0x07UL</span><br><span class="line">//#define configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY            1</span><br><span class="line">//#define configALLOW_UNPRIVILEGED_CRITICAL_SECTIONS             1</span><br><span class="line"></span><br><span class="line">/* ARMv8-M 安全侧端口相关定义。 */</span><br><span class="line">//#define secureconfigMAX_SECURE_CONTEXTS         5</span><br><span class="line"></span><br><span class="line">#endif /* FREERTOS_CONFIG_H */</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="FreeRTOS-数据类型"><a href="#FreeRTOS-数据类型" class="headerlink" title="FreeRTOS 数据类型"></a>FreeRTOS 数据类型</h2><p>针对每个移植定义四种类型。即：</p>
<h3 id="TickType-t"><a href="#TickType-t" class="headerlink" title="TickType_t"></a>TickType_t</h3><p>如果 configUSE_16_BIT_TICKS 设置为非零 (true) ，则将 TickType_t<br>定义为无符号的 16 位类型。如果 configUSE_16_BIT_TICKS<br>设置为零（假），则将 TickType_t 定义为无符号的 32 位类型。</p>
<p>这个类型的变量,<br>通常用来表示系统节拍计数器的值。FreeRTOS 系统中，每隔一段时间会进行一次滴答定时器中断处理，这个时间间隔就是系统的节拍周期。TickType_t 类型的变量记录了系统过去的节拍次数。</p>
<h3 id="BaseType-t"><a href="#BaseType-t" class="headerlink" title="BaseType_t"></a>BaseType_t</h3><p>架构中最有效、最自然的类型。例如，在 32 位架构上，BaseType_t 会被定义为<br>32 位类型。在 16 位架构上，BaseType_t 会被定义为 16 位类型。是有符号的.</p>
<h3 id="UBaseType-t"><a href="#UBaseType-t" class="headerlink" title="UBaseType_t"></a>UBaseType_t</h3><p>是无符号的 BaseType_t</p>
<h3 id="StackType-t"><a href="#StackType-t" class="headerlink" title="StackType_t"></a>StackType_t</h3><p>意指架构用于存储堆栈项目的 类型。通常是 16 位架构上的 16 位类型和 32<br>位架构上的 32 位类型，但也有例外情况。<strong>供 FreeRTOS 内部使用</strong>。</p>
<h2 id="FreeROS-的命名规范"><a href="#FreeROS-的命名规范" class="headerlink" title="FreeROS 的命名规范"></a>FreeROS 的命名规范</h2><p>了解 FreeRTOS 的编码规范,有助于我们理解和学习 FreeRTOS 的使用.</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol>
<li><p>变量名称使用驼峰式大小写，具有明确的描述性，并使用完整的单词（没有缩写，但普遍接受的缩写除外）。</p>
</li>
<li><p>uint32_t 类型变量以 ul 为前缀，其中”u”表示”unsigned”<br>，”l”表示”long”。</p>
</li>
<li><p>uint16_t 类型变量以 us 为前缀，其中”u”表示”unsigned” ，<br>“s”表示”short”。</p>
</li>
<li><p>uint8_t 类型变量以 uc 为前缀，其中”u”表示”unsigned” ， “c”表示”char<br>“。</p>
</li>
<li><p>非 stdint 类型的变量以 x 为前缀。例如，BaseType_t 和<br>TickType_t，二者分别是可移植层定义的定义类型，主要架构的自然类型或最有效类型，以及用于保存<br>RTOS ticks 计数的类型。</p>
</li>
<li><p>非 stdint 类型的未签名变量存在附加前缀<br>u。例如，UBaseType_t（无符号的 BaseType_t）类型变量以 ux 为前缀。</p>
</li>
<li><p>size_t 类型变量也带有 x 前缀。</p>
</li>
<li><p>枚举变量以 e 为前缀</p>
</li>
<li><p>指针以附加 p 为前缀，例如，指向 uint16_t 的指针将以 pus 为前缀。</p>
</li>
<li><p>根据 MISRA 指南，无符号 char 类型仅可包含 ASCII 字符，并以 c<br>为前缀。</p>
</li>
<li><p>根据 MISRA 指南，char * 类型变量仅可包含指向 ASCII<br>字符串的指针，并以 pc 为前缀。</p>
</li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol start="12">
<li><p>函数名称使用驼峰式大小写，具有明确的描述性，并使用完整的单词（无缩写，但普遍接受的缩写除外）。</p>
</li>
<li><p>文件作用域静态（私有）函数以 prv 为前缀。</p>
</li>
<li><p>根据变量定义的相关规定，API 函数以其<strong>返回类型为前缀</strong>，并为 void<br>添加前缀 v。</p>
</li>
<li><p>API 函数名称以定义 API 函数文件的名称开头。</p>
</li>
</ol>
<p>比如一个函数 <strong>vTaskDelay</strong> ,<br>从函数名可以得到如下信息:v 表示这个函数的返回值是 void,<br>Task 表示这个函数定义在 Task.c 文件中, Delay 表示函数的功能</p>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><ol start="16">
<li><p>宏具有明确的描述性，并使用完整的单词（无缩写，但普遍接受的缩写除外）。</p>
</li>
<li><p>宏以定义宏的文件为前缀。前缀为小写。例如，在 FreeRTOSConfig.h 中定义<br>configUSE_PREEMPTION。</p>
</li>
<li><p>除前缀外，所有宏均使用大写字母书写，并使用下划线来分隔单词。</p>
</li>
</ol>
<h1 id="FreeRTOS-的任务创建和删除"><a href="#FreeRTOS-的任务创建和删除" class="headerlink" title="FreeRTOS 的任务创建和删除"></a>FreeRTOS 的任务创建和删除</h1><h2 id="任务创建和删除的-API-函数（熟悉）"><a href="#任务创建和删除的-API-函数（熟悉）" class="headerlink" title="任务创建和删除的 API 函数（熟悉）"></a>任务创建和删除的 API 函数（熟悉）</h2><p>任务的创建和删除本质就是调用 FreeRTOS 的 API 函数，主要如下：</p>
<hr>
<p>API 函数 描述</p>
<hr>
<p>xTaskCreate() 动态方式创建任务</p>
<p>xTaskCreateStatic() 静态方式创建任务</p>
<p>vTaskDelete() 删除任务</p>
<hr>
<ul>
<li><p>动态创建任务：任务的任务控制块以及任务的栈空间所需的内存，均由<br>FreeRTOS 从 FreeRTOS 管理的堆中分配。</p>
</li>
<li><p>静态创建任务：任务的任务控制块以及任务的栈空间所需的内存，需用户分配提供。</p>
</li>
</ul>
<h3 id="动态创建任务函数"><a href="#动态创建任务函数" class="headerlink" title="动态创建任务函数"></a>动态创建任务函数</h3><ol>
<li>函数说明</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t xTaskCreate</span><br><span class="line">(</span><br><span class="line">    TaskFunction_t pxTaskCode,                  /* 指向任务函数的指针 */</span><br><span class="line">    const char * const pcName,                  /* 任务名字，最大长度configMAX_TASK_NAME_LEN */</span><br><span class="line">    const configSTACK_DEPTH_TYPE usStackDepth,  /* 任务堆栈大小，默认单位4字节 */</span><br><span class="line">    void * const pvParameters,                  /* 传递给任务函数的参数 */</span><br><span class="line">    UBaseType_t uxPriority,                     /* 任务优先级，范围：0 ~ configMAX_PRIORITIES - 1 */</span><br><span class="line">    TaskHandle_t * const pxCreatedTask          /* 任务句柄，就是任务的任务控制块 */</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回值说明如下：</p>
<ul>
<li><p>pdPASS：任务创建成功。</p>
</li>
<li><p>errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY：任务创建失败。</p>
<ol>
<li><p>动态创建任务步骤</p>
<ol>
<li><p>将宏 configSUPPORT_DYNAMIC_ALLOCATION 配置为 1。</p>
</li>
<li><p>定义函数入口参数。</p>
</li>
<li><p>编写任务函数。</p>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<p>此函数创建的任务会立刻进入就绪态，由任务调度器调度运行。</p>
<ol start="2">
<li><p>动态创建任务函数内部实现</p>
<ol>
<li><p>申请堆栈内存&amp;任务控制块内存。</p>
</li>
<li><p>TCB 结构体成员赋值。</p>
</li>
<li><p>添加新任务到就绪列表中。</p>
</li>
</ol>
</li>
</ol>
<p>任务控制块结构体成员介绍。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tskTaskControlBlock</span><br><span class="line">&#123;</span><br><span class="line">    volatile StackType_t * pxTopOfStack; /* 任务栈栈顶，必须为TCB的第一个成员 */</span><br><span class="line">    ListItem_t xStateListItem;                  /* 任务状态列表项 */</span><br><span class="line">    ListItem_t xEventListItem;                  /* 任务事件列表项 */</span><br><span class="line">    UBaseType_t uxPriority;                     /* 任务优先级，数值越大，优先级越大 */</span><br><span class="line">    StackType_t * pxStack;                      /* 任务栈起始地址 */</span><br><span class="line">    char pcTaskName[ configMAX_TASK_NAME_LEN ]; /* 任务名字 */</span><br><span class="line">    …</span><br><span class="line">    省略很多条件编译的成员</span><br><span class="line">&#125; tskTCB;</span><br></pre></td></tr></table></figure>

<p>任务栈栈顶，在任务切换时的任务上下文保存、任务恢复息息相关。每个任务都有属于自己的任务控制块，类似身份证。</p>
<h3 id="静态创建任务函数"><a href="#静态创建任务函数" class="headerlink" title="静态创建任务函数"></a>静态创建任务函数</h3><ol>
<li>函数说明</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t xTaskCreateStatic</span><br><span class="line">(</span><br><span class="line">    TaskFunction_t pxTaskCode,          /* 指向任务函数的指针 */</span><br><span class="line">    const char * const pcName,          /* 任务函数名 */</span><br><span class="line">    const uint32_t ulStackDepth,        /* 任务堆栈大小,单位是4字节 */</span><br><span class="line">    void * const pvParameters,          /* 传递的任务函数参数 */</span><br><span class="line">    UBaseType_t uxPriority,             /* 任务优先级 */</span><br><span class="line">    StackType_t * const puxStackBuffer, /* 任务堆栈，一般为数组，由用户分配 */</span><br><span class="line">    StaticTask_t * const pxTaskBuffer   /* 任务控制块指针，由用户分配 */</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>返回值如下：</p>
<ul>
<li><p>NULL：用户没有提供相应的内存，任务创建失败。</p>
</li>
<li><p>其他值：任务句柄，任务创建成功。</p>
<ol>
<li><p>静态创建任务步骤</p>
<ol>
<li><p>将宏 configSUPPORT_STATIC_ALLOCATION 配置为 1。</p>
</li>
<li><p>定义空闲任务&amp;定时器任务的任务堆栈及 TCB。</p>
</li>
<li><p>实现接口函数：</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>vApplicationGetIdleTaskMemory()</p>
</li>
<li><p>vApplicationGetTimerTaskMemory()（如果开启软件定时器）</p>
<ol>
<li><p>定义函数入口参数。</p>
</li>
<li><p>编写任务函数。</p>
</li>
</ol>
</li>
</ul>
<p>此函数创建的任务会立刻进入就绪态，由任务调度器调度运行。</p>
<ol>
<li><p>静态创建内部实现</p>
<ol>
<li><p>TCB 结构体成员赋值</p>
</li>
<li><p>添加新任务到就绪列表中</p>
</li>
</ol>
</li>
</ol>
<h3 id="任务删除函数"><a href="#任务删除函数" class="headerlink" title="任务删除函数"></a>任务删除函数</h3><ol>
<li>函数说明</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void vTaskDelete( TaskHandle_t xTaskToDelete )</span><br></pre></td></tr></table></figure>

<p>参数说明：xTaskToDelete 待删除任务的任务句柄。当传入的参数为 NULL，则代表删除任务自身（当前正在运行的任务）。</p>
<p>该函数用于删除已被创建的任务，被删除的任务将从就绪态任务列表、阻塞态任务列表、挂起态任务列表和事件列表中移除。</p>
<p>需要注意的是，空闲任务会负责释放被删除任务中由系统分配的内存，但是由用户在任务删除前申请的内存，则需要由用户在任务被删除前提前释放，否则将导致内存泄露。</p>
<ol start="2">
<li><p>删除任务流程</p>
<ol>
<li><p>使用删除任务函数，需将宏 INCLUDE_vTaskDelete 配置为 1</p>
</li>
<li><p>入口参数输入需要删除的任务句柄（NULL 代表删除本身）</p>
</li>
</ol>
</li>
<li><p>内部实现过程</p>
<ol>
<li>获取所要删除任务的控制块</li>
</ol>
</li>
</ol>
<p>通过传入的任务句柄，判断所需要删除哪个任务，NULL 代表删除自身。</p>
<ol start="2">
<li>将被删除任务，移除所在列表</li>
</ol>
<p>将该任务在所在列表中移除，包括：就绪、阻塞、挂起、事件等列表。</p>
<ol start="3">
<li>判断所需要删除的任务</li>
</ol>
<p>如果删除任务自身，需先添加到等待删除列表，内存释放将在空闲任务执行；如果删除其他任务，释放内存，任务数量–。</p>
<ol start="4">
<li>更新下个任务的阻塞时间</li>
</ol>
<p>更新下一个任务的阻塞超时时间，以防被删除的任务就是下一个阻塞超时的任务。</p>
<h2 id="任务创建和删除实验（动态方法）（掌握）"><a href="#任务创建和删除实验（动态方法）（掌握）" class="headerlink" title="任务创建和删除实验（动态方法）（掌握）"></a>任务创建和删除实验（动态方法）（掌握）</h2><p>动态创建，堆栈是在 FreeRTOS 管理的堆内存里，注意任务不要重复创建。</p>
<p>xxxxx_STACK_SIZE 128</p>
<p>uxTaskGetStackHighWaterMark()获取指定任务的任务栈的历史剩余最小值，根据这个结果适当调整启动任务的大小。</p>
<h3 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h3><p>学会 xTaskCreate( ) 和 vTaskDelete( ) 的使用：</p>
<ul>
<li><p>start_task：用来创建其他的三个任务。</p>
</li>
<li><p>task1：实现 LED1 每 500ms 闪烁一次。</p>
</li>
<li><p>task2：实现 LED2 每 500ms 闪烁一次。</p>
</li>
<li><p>task3：判断按键 KEY1 是否按下，按下则删掉 task1。</p>
</li>
</ul>
<h3 id="FreeRTOSConfig-h-代码清单"><a href="#FreeRTOSConfig-h-代码清单" class="headerlink" title="FreeRTOSConfig.h 代码清单"></a>FreeRTOSConfig.h 代码清单</h3><p>#define configSUPPORT_DYNAMIC_ALLOCATION 1</p>
<h3 id="freertos-demo-c-代码清单"><a href="#freertos-demo-c-代码清单" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li>任务设置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* 启动任务函数 */</span><br><span class="line">#define START_TASK_PRIORITY 1</span><br><span class="line">#define START_TASK_STACK_DEPTH 128</span><br><span class="line">TaskHandle_t start_task_handler;</span><br><span class="line">void Start_Task(void *pvParameters);</span><br><span class="line"></span><br><span class="line">/* Task1 任务 配置 */</span><br><span class="line">#define TASK1_PRIORITY 2</span><br><span class="line">#define TASK1_STACK_DEPTH 128</span><br><span class="line">TaskHandle_t task1_handler;</span><br><span class="line">void Task1(void *pvParameters);</span><br><span class="line"></span><br><span class="line">/* Task2 任务 配置 */</span><br><span class="line">#define TASK2_PRIORITY 3</span><br><span class="line">#define TASK2_STACK_DEPTH 128</span><br><span class="line">TaskHandle_t task2_handler;</span><br><span class="line">void Task2(void *pvParameters);</span><br><span class="line"></span><br><span class="line">/* Task3 任务 配置 */</span><br><span class="line">#define TASK3_PRIORITY 4</span><br><span class="line">#define TASK3_STACK_DEPTH 128</span><br><span class="line">TaskHandle_t task3_handler;</span><br><span class="line">void Task3(void *pvParameters);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>入口函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: FreeRTOS入口函数：创建任务函数并开始调度</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void FreeRTOS_Start(void)</span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreate((TaskFunction_t)Start_Task,</span><br><span class="line">                (char *)&quot;Start_Task&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE)START_TASK_STACK_DEPTH,</span><br><span class="line">                (void *)NULL,</span><br><span class="line">                (UBaseType_t)START_TASK_PRIORITY,</span><br><span class="line">                (TaskHandle_t *)&amp;start_task_handler);</span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动任务函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void Start_Task( void * pvParameters )</span><br><span class="line">&#123;</span><br><span class="line">    taskENTER_CRITICAL();               /* 进入临界区 */</span><br><span class="line">    xTaskCreate((TaskFunction_t         )   Task1,</span><br><span class="line">                (char *                 )   &quot;Task1&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE )   TASK1_STACK_DEPTH,</span><br><span class="line">                (void *                 )   NULL,</span><br><span class="line">                (UBaseType_t            )   TASK1_PRIORITY,</span><br><span class="line">                (TaskHandle_t *         )   &amp;task1_handler );</span><br><span class="line"></span><br><span class="line">    xTaskCreate((TaskFunction_t         )   Task2,</span><br><span class="line">                (char *                 )   &quot;Task2&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE )   TASK2_STACK_DEPTH,</span><br><span class="line">                (void *                 )   NULL,</span><br><span class="line">                (UBaseType_t            )   TASK2_PRIORITY,</span><br><span class="line">                (TaskHandle_t *         )   &amp;task2_handler );</span><br><span class="line"></span><br><span class="line">    xTaskCreate((TaskFunction_t         )   Task3,</span><br><span class="line">                (char *                 )   &quot;Task2&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE )   TASK3_STACK_DEPTH,</span><br><span class="line">                (void *                 )   NULL,</span><br><span class="line">                (UBaseType_t            )   TASK3_PRIORITY,</span><br><span class="line">                (TaskHandle_t *         )   &amp;task3_handler );</span><br><span class="line">    vTaskDelete(NULL);</span><br><span class="line">    taskEXIT_CRITICAL();                /* 退出临界区 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>task1 函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: LED1每500ms翻转一次</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task1(void * pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;task1运行....\r\n&quot;);</span><br><span class="line">        LED_Toggle(LED1_Pin);</span><br><span class="line">        vTaskDelay(500);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>task2 函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: LED2每500ms翻转一次</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task2(void * pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;task2运行....\r\n&quot;);</span><br><span class="line">        LED_Toggle(LED2_Pin);</span><br><span class="line">        vTaskDelay(500);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>task3 函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 按下KEY1删除task1</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task3(void * pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t key = 0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;task3正在运行...\r\n&quot;);</span><br><span class="line">        key = Key_Detect();</span><br><span class="line">        if(key == KEY1_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            if(task1_handler != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;删除task1任务...\r\n&quot;);</span><br><span class="line">                vTaskDelete(task1_handler);</span><br><span class="line">                task1_handler = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务创建和删除实验（静态方法）（掌握）"><a href="#任务创建和删除实验（静态方法）（掌握）" class="headerlink" title="任务创建和删除实验（静态方法）（掌握）"></a>任务创建和删除实验（静态方法）（掌握）</h2><h3 id="实验目标-1"><a href="#实验目标-1" class="headerlink" title="实验目标"></a>实验目标</h3><p>学会 xTaskCreateStatic( )和 vTaskDelete( ) 的使用：</p>
<ul>
<li><p>start_task：用来创建其他的三个任务。</p>
</li>
<li><p>task1：实现 LED1 每 500ms 闪烁一次。</p>
</li>
<li><p>task2：实现 LED2 每 500ms 闪烁一次。</p>
</li>
<li><p>task3：判断按键 KEY1 是否按下，按下则删掉 task1。</p>
</li>
</ul>
<h3 id="FreeRTOSConfig-h-代码清单-1"><a href="#FreeRTOSConfig-h-代码清单-1" class="headerlink" title="FreeRTOSConfig.h 代码清单"></a>FreeRTOSConfig.h 代码清单</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define configSUPPORT_STATIC_ALLOCATION 1</span><br></pre></td></tr></table></figure>

<h3 id="freertos-demo-c-代码清单-1"><a href="#freertos-demo-c-代码清单-1" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li>任务设置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/* START_TASK 任务 配置</span><br><span class="line"> * 包括: 任务句柄 任务优先级 堆栈大小 创建任务</span><br><span class="line"> */</span><br><span class="line">#define START_TASK_PRIO         1</span><br><span class="line">#define START_TASK_STACK_SIZE   128</span><br><span class="line">TaskHandle_t    start_task_handler;</span><br><span class="line">StackType_t     start_task_stack[START_TASK_STACK_SIZE];</span><br><span class="line">StaticTask_t    start_task_tcb;</span><br><span class="line">void start_task( void * pvParameters );</span><br><span class="line"></span><br><span class="line">/* TASK1 任务 配置</span><br><span class="line"> * 包括: 任务句柄 任务优先级 堆栈大小 创建任务</span><br><span class="line"> */</span><br><span class="line">#define TASK1_PRIO         2</span><br><span class="line">#define TASK1_STACK_SIZE   128</span><br><span class="line">TaskHandle_t    task1_handler;</span><br><span class="line">StackType_t     task1_stack[TASK1_STACK_SIZE];</span><br><span class="line">StaticTask_t    task1_tcb;</span><br><span class="line">void task1( void * pvParameters );</span><br><span class="line"></span><br><span class="line">/* TASK2 任务 配置</span><br><span class="line"> * 包括: 任务句柄 任务优先级 堆栈大小 创建任务</span><br><span class="line"> */</span><br><span class="line">#define TASK2_PRIO         3</span><br><span class="line">#define TASK2_STACK_SIZE   128</span><br><span class="line">TaskHandle_t    task2_handler;</span><br><span class="line">StackType_t     task2_stack[TASK2_STACK_SIZE];</span><br><span class="line">StaticTask_t    task2_tcb;</span><br><span class="line">void task2( void * pvParameters );</span><br><span class="line"></span><br><span class="line">/* TASK3 任务 配置</span><br><span class="line"> * 包括: 任务句柄 任务优先级 堆栈大小 创建任务</span><br><span class="line"> */</span><br><span class="line">#define TASK3_PRIO         4</span><br><span class="line">#define TASK3_STACK_SIZE   128</span><br><span class="line">TaskHandle_t    task3_handler;</span><br><span class="line">StackType_t     task3_stack[TASK3_STACK_SIZE];</span><br><span class="line">StaticTask_t    task3_tcb;</span><br><span class="line">void task3( void * pvParameters );</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>空闲任务置及接口函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 空闲任务配置 */</span><br><span class="line">StaticTask_t idle_task_tcb;</span><br><span class="line">StackType_t  idle_task_stack[configMINIMAL_STACK_SIZE];</span><br><span class="line"></span><br><span class="line">/* 软件定时器任务配置 */</span><br><span class="line">StaticTask_t timer_task_tcb;</span><br><span class="line">StackType_t  timer_task_stack[configTIMER_TASK_STACK_DEPTH];</span><br><span class="line"></span><br><span class="line">/* 空闲任务内存分配 */</span><br><span class="line">void vApplicationGetIdleTaskMemory( StaticTask_t ** ppxIdleTaskTCBBuffer,</span><br><span class="line">                                    StackType_t ** ppxIdleTaskStackBuffer,</span><br><span class="line">                                    uint32_t * pulIdleTaskStackSize )</span><br><span class="line">&#123;</span><br><span class="line">    * ppxIdleTaskTCBBuffer = &amp;idle_task_tcb;</span><br><span class="line">    * ppxIdleTaskStackBuffer = idle_task_stack;</span><br><span class="line">    * pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>入口函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: FreeRTOS入口函数：创建任务函数并开始调度</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void FreeRTOS_Start(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    start_task_handler = xTaskCreateStatic((TaskFunction_t)Start_Task,</span><br><span class="line">                                           (char *)&quot;Start_Task&quot;,</span><br><span class="line">                                           (uint32_t)START_TASK_STACK_DEPTH,</span><br><span class="line">                                           (void *)NULL,</span><br><span class="line">                                           (UBaseType_t)START_TASK_PRIORITY,</span><br><span class="line">                                           (StackType_t *)start_task_stack,</span><br><span class="line">                                           (StaticTask_t *)&amp;start_task_tcb);</span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>启动函数</li>
</ol>
<figure class="highlight plaintext"><figcaption><span>Start_Task(void *pvParameters)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    taskENTER_CRITICAL(); /* 进入临界区 */</span><br><span class="line"></span><br><span class="line">    task1_handler = xTaskCreateStatic((TaskFunction_t)Task1,</span><br><span class="line">                                      (char *)&quot;Task1&quot;,</span><br><span class="line">                                      (uint32_t)TASK1_STACK_DEPTH,</span><br><span class="line">                                      (void *)NULL,</span><br><span class="line">                                      (UBaseType_t)TASK1_PRIORITY,</span><br><span class="line">                                      (StackType_t *)task1_stack,</span><br><span class="line">                                      (StaticTask_t *)&amp;task1_tcb);</span><br><span class="line"></span><br><span class="line">    task2_handler = xTaskCreateStatic((TaskFunction_t)Task2,</span><br><span class="line">                                      (char *)&quot;Task2&quot;,</span><br><span class="line">                                      (uint32_t)TASK2_STACK_DEPTH,</span><br><span class="line">                                      (void *)NULL,</span><br><span class="line">                                      (UBaseType_t)TASK2_PRIORITY,</span><br><span class="line">                                      (StackType_t *)task2_stack,</span><br><span class="line">                                      (StaticTask_t *)&amp;task2_tcb);</span><br><span class="line"></span><br><span class="line">    task3_handler = xTaskCreateStatic((TaskFunction_t)Task3,</span><br><span class="line">                                      (char *)&quot;Task3&quot;,</span><br><span class="line">                                      (uint32_t)TASK3_STACK_DEPTH,</span><br><span class="line">                                      (void *)NULL,</span><br><span class="line">                                      (UBaseType_t)TASK3_PRIORITY,</span><br><span class="line">                                      (StackType_t *)task3_stack,</span><br><span class="line">                                      (StaticTask_t *)&amp;task3_tcb);</span><br><span class="line"></span><br><span class="line">    vTaskDelete(start_task_handler);</span><br><span class="line"></span><br><span class="line">    taskEXIT_CRITICAL(); /* 退出临界区 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FreeRTOS-的任务挂起与恢复"><a href="#FreeRTOS-的任务挂起与恢复" class="headerlink" title="FreeRTOS 的任务挂起与恢复"></a>FreeRTOS 的任务挂起与恢复</h1><h2 id="任务的挂起与恢复的-API-函数（熟悉）"><a href="#任务的挂起与恢复的-API-函数（熟悉）" class="headerlink" title="任务的挂起与恢复的 API 函数（熟悉）"></a>任务的挂起与恢复的 API 函数（熟悉）</h2><ul>
<li><p>vTaskSuspend()：挂起任务, 类似暂停，可恢复</p>
</li>
<li><p>vTaskResume()：恢复被挂起的任务</p>
</li>
<li><p>xTaskResumeFromISR()：在中断中恢复被挂起的任务</p>
</li>
</ul>
<h3 id="任务挂起函数"><a href="#任务挂起函数" class="headerlink" title="任务挂起函数"></a>任务挂起函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void vTaskSuspend( TaskHandle_t xTaskToSuspend )</span><br></pre></td></tr></table></figure>

<ul>
<li><p>xTaskToSuspend：待挂起任务的任务句柄，为 NULL 表示挂起任务自身。</p>
</li>
<li><p>需将宏 INCLUDE_vTaskSuspend 配置为 1。</p>
</li>
</ul>
<h3 id="任务恢复函数"><a href="#任务恢复函数" class="headerlink" title="任务恢复函数"></a>任务恢复函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void vTaskResume( TaskHandle_t xTaskToResume )</span><br></pre></td></tr></table></figure>

<ul>
<li><p>INCLUDE_vTaskSuspend 必须定义为 1。</p>
</li>
<li><p>不论任务被使用 vTaskSuspend() 挂起多少次，只需调用 vTaskResume()<br>一次，即可使其继续执行。被恢复的任务会重新进入就绪状态。</p>
</li>
</ul>
<h3 id="任务恢复函数（中断中恢复）"><a href="#任务恢复函数（中断中恢复）" class="headerlink" title="任务恢复函数（中断中恢复）"></a>任务恢复函数（中断中恢复）</h3><ol>
<li>函数说明</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )</span><br></pre></td></tr></table></figure>

<p>返回值如下：</p>
<ul>
<li><p>pdTRUE：任务恢复后需要进行任务切换。</p>
</li>
<li><p>pdFALSE：任务恢复后不需要进行任务切换。</p>
<ol>
<li>注意事项</li>
</ol>
</li>
<li><p>INCLUDE_vTaskSuspend 和 INCLUDE_xTaskResumeFromISR 必须定义为 1。</p>
</li>
<li><p>在中断服务程序中调用 FreeRTOS 的 API 函数时，中断的优先级不能高于 FreeRTOS 所管理的最高中断优先级。</p>
</li>
</ul>
<h3 id="挂起与恢复调度器"><a href="#挂起与恢复调度器" class="headerlink" title="挂起与恢复调度器"></a>挂起与恢复调度器</h3><ul>
<li><p>vTaskSuspendAll()：挂起任务调度器，调度器不会进行任务切换，当前任务一直运行。</p>
</li>
<li><p>xTaskResumeAll()：恢复任务调度器，调度器继续任务切换。</p>
</li>
</ul>
<h2 id="任务挂起与恢复实验（掌握）"><a href="#任务挂起与恢复实验（掌握）" class="headerlink" title="任务挂起与恢复实验（掌握）"></a>任务挂起与恢复实验（掌握）</h2><h3 id="实验目标-2"><a href="#实验目标-2" class="headerlink" title="实验目标"></a>实验目标</h3><p>学会 vTaskSuspend( )、vTaskResume( ) 任务挂起与恢复及 vTaskSuspendAll(<br>)、xTaskResumeAll( )挂起与恢复调度器的相关 API 函数使用：</p>
<ul>
<li><p>start_task:用来创建其他的三个任务。</p>
</li>
<li><p>task1：实现 LED1 每 500ms 闪烁一次。</p>
</li>
<li><p>task2：实现 LED2 每 500ms 闪烁一次。</p>
</li>
<li><p>task3：判断按键按下逻辑，KEY1 按下，挂起 task1，按下 KEY2 在任务中恢复 task1，KEY3 按下，挂起调度器，KEY4 按下，恢复调度器，并打印任务的状态。</p>
</li>
</ul>
<h3 id="FreeRTOSConfig-h-代码清单-2"><a href="#FreeRTOSConfig-h-代码清单-2" class="headerlink" title="FreeRTOSConfig.h 代码清单"></a>FreeRTOSConfig.h 代码清单</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define INCLUDE_vTaskSuspend                            1</span><br><span class="line">#define INCLUDE_xResumeFromISR                          1</span><br><span class="line"></span><br><span class="line">/* 开启跟踪task信息 */</span><br><span class="line">#define configUSE_TRACE_FACILITY 1</span><br><span class="line">#define configUSE_STATS_FORMATTING_FUNCTIONS 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="freertos-demo-c-代码清单-2"><a href="#freertos-demo-c-代码清单-2" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li>任务设置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* 启动任务函数 */</span><br><span class="line">#define START_TASK_PRIORITY 1</span><br><span class="line">#define START_TASK_STACK_DEPTH 128</span><br><span class="line">TaskHandle_t start_task_handler;</span><br><span class="line">void Start_Task(void *pvParameters);</span><br><span class="line"></span><br><span class="line">/* Task1 任务 配置 */</span><br><span class="line">#define TASK1_PRIORITY 2</span><br><span class="line">#define TASK1_STACK_DEPTH 128</span><br><span class="line">TaskHandle_t task1_handler;</span><br><span class="line">void Task1(void *pvParameters);</span><br><span class="line"></span><br><span class="line">/* Task2 任务 配置 */</span><br><span class="line">#define TASK2_PRIORITY 3</span><br><span class="line">#define TASK2_STACK_DEPTH 128</span><br><span class="line">TaskHandle_t task2_handler;</span><br><span class="line">void Task2(void *pvParameters);</span><br><span class="line"></span><br><span class="line">/* Task3 任务 配置 */</span><br><span class="line">#define TASK3_PRIORITY 4</span><br><span class="line">#define TASK3_STACK_DEPTH 128</span><br><span class="line">TaskHandle_t task3_handler;</span><br><span class="line">void Task3(void *pvParameters);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>入口函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: FreeRTOS入口函数：创建任务函数并开始调度</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void FreeRTOS_Start(void)</span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreate((TaskFunction_t)Start_Task,</span><br><span class="line">                (char *)&quot;Start_Task&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE)START_TASK_STACK_DEPTH,</span><br><span class="line">                (void *)NULL,</span><br><span class="line">                (UBaseType_t)START_TASK_PRIORITY,</span><br><span class="line">                (TaskHandle_t *)&amp;start_task_handler);</span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动任务函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void Start_Task( void * pvParameters )</span><br><span class="line">&#123;</span><br><span class="line">    taskENTER_CRITICAL();               /* 进入临界区 */</span><br><span class="line">    xTaskCreate((TaskFunction_t         )   Task1,</span><br><span class="line">                (char *                 )   &quot;Task1&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE )   TASK1_STACK_DEPTH,</span><br><span class="line">                (void *                 )   NULL,</span><br><span class="line">                (UBaseType_t            )   TASK1_PRIORITY,</span><br><span class="line">                (TaskHandle_t *         )   &amp;task1_handler );</span><br><span class="line"></span><br><span class="line">    xTaskCreate((TaskFunction_t         )   Task2,</span><br><span class="line">                (char *                 )   &quot;Task2&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE )   TASK2_STACK_DEPTH,</span><br><span class="line">                (void *                 )   NULL,</span><br><span class="line">                (UBaseType_t            )   TASK2_PRIORITY,</span><br><span class="line">                (TaskHandle_t *         )   &amp;task2_handler );</span><br><span class="line"></span><br><span class="line">    xTaskCreate((TaskFunction_t         )   Task3,</span><br><span class="line">                (char *                 )   &quot;Task2&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE )   TASK3_STACK_DEPTH,</span><br><span class="line">                (void *                 )   NULL,</span><br><span class="line">                (UBaseType_t            )   TASK3_PRIORITY,</span><br><span class="line">                (TaskHandle_t *         )   &amp;task3_handler );</span><br><span class="line">    vTaskDelete(NULL);</span><br><span class="line">    taskEXIT_CRITICAL();                /* 退出临界区 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>task1 函数</p>
</li>
<li><p>task2 函数</p>
</li>
<li><p>task3 函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 按下KEY1挂起task1，按下KEY2恢复task1</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">char task_info[500];</span><br><span class="line">void Task3(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t key = 0;</span><br><span class="line">    while (1)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;task3运行....\r\n&quot;);</span><br><span class="line">        key = Key_Detect();</span><br><span class="line">        if (key == KEY1_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;挂起task1...\r\n&quot;);</span><br><span class="line">            vTaskSuspend(task1_handler);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (key == KEY2_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;恢复task1...\r\n&quot;);</span><br><span class="line">            vTaskResume(task1_handler);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (key == KEY3_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            /* 按下KEY3，挂起调度器 */</span><br><span class="line">            printf(&quot;挂起调度器....\r\n&quot;);</span><br><span class="line">            vTaskSuspendAll();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (key == KEY4_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            /* 按下KEY4，恢复调度器 */</span><br><span class="line">            printf(&quot;恢复调度器....\r\n&quot;);</span><br><span class="line">            xTaskResumeAll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vTaskList(task_info);</span><br><span class="line">        printf(&quot;%s\r\n&quot;,task_info);</span><br><span class="line"></span><br><span class="line">        vTaskDelay(10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FreeRTOS-中断管理"><a href="#FreeRTOS-中断管理" class="headerlink" title="FreeRTOS 中断管理"></a>FreeRTOS 中断管理</h1><h2 id="FreeRTOS-中断管理（熟悉）"><a href="#FreeRTOS-中断管理（熟悉）" class="headerlink" title="FreeRTOS 中断管理（熟悉）"></a>FreeRTOS 中断管理（熟悉）</h2><h3 id="FreeRTOS-的中断管理"><a href="#FreeRTOS-的中断管理" class="headerlink" title="FreeRTOS 的中断管理"></a>FreeRTOS 的中断管理</h3><p>在 STM32 中，中断优先级是通过中断优先级配置寄存器的高 4 位 [7:4]<br>来配置的。因此 STM32 支持最多 16 级中断优先级，其中数值越小表示优先级越高，即更紧急的中断。（FreeRTOS 任务调度的任务优先级相反，是数值越大越优先）</p>
<p>FreeRTOS 可以与 STM32 原生的中断机制结合使用，但它提供了自己的中断管理机制，主要是为了提供更强大和灵活的任务调度和管理功能。</p>
<p>FreeRTOS 中，将 PendSV 和 SysTick 设置最低中断优先级（数值最大，15），保证系统任务切换不会阻塞系统其他中断的响应。</p>
<p>FreeRTOS 利用<strong>BASEPRI</strong>寄存器实现中断管理，屏蔽优先级低于某一个阈值的中断。比如：<br><strong>BASEPRI</strong>设置为 0x50（只看高四位，也就是 5），代表中断优先级在 5~15 内的均被屏蔽，0~4 的中断优先级正常执行。</p>
<p>在中断服务函数中调用 FreeRTOS 的 API 函数需注意：</p>
<ul>
<li><p>中断服务函数的优先级需在 FreeRTOS 所管理的范围内，阈值由 configMAX_SYSCALL_INTERRUPT_PRIORITY 指定。</p>
</li>
<li><p>建议将<strong>所有优先级位指定为抢占优先级位</strong>，方便 FreeRTOS 管理。</p>
</li>
<li><p>在中断服务函数里边需调用 FreeRTOS 的 API 函数，必须使用带”<strong>FromISR</strong>“后缀的函数。</p>
</li>
</ul>
<h3 id="FreeRTOS-的开关中断"><a href="#FreeRTOS-的开关中断" class="headerlink" title="FreeRTOS 的开关中断"></a>FreeRTOS 的开关中断</h3><p>FreeRTOS 开关中断函数其实是宏定义，在 portmacro.h 中有定义，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define portDISABLE_INTERRUPTS() vPortRaiseBASEPRI()</span><br><span class="line"></span><br><span class="line">#define portENABLE_INTERRUPTS() vPortSetBASEPRI( 0 )</span><br></pre></td></tr></table></figure>

<p>调用 portENABLE_INTERRUPTS() 它, FreeRTOS 会打开管理的所有中断</p>
<p>调用 portDISABLE_INTERRUPTS() 它, FreeRTOS 会关闭管理的所有中断</p>
<h3 id="FreeRTOS-的临界段代码"><a href="#FreeRTOS-的临界段代码" class="headerlink" title="FreeRTOS 的临界段代码"></a>FreeRTOS 的临界段代码</h3><p>临界段代码，又称为临界区，指的是那些必须在不被打断的情况下完整运行的代码段。例如，某些外设的初始化可能要求严格的时序，因此在初始化过程中不允许被中断打断。在 FreeRTOS 中，进入临界段代码时需要关闭中断，在处理完临界段代码后再重新开启中断。FreeRTOS 系统本身包含许多临界段代码，并对其进行了保护。在编写用户程序时，有些情况下也需要添加临界段代码以确保代码的完整性。</p>
<p>与临界段代码保护有关的函数有 4 个：</p>
<ul>
<li><p>taskENTER_CRITICAL() ：进入临界段。</p>
</li>
<li><p>taskEXIT_CRITICAL() ：退出临界段。</p>
</li>
<li><p>taskENTER_CRITICAL_FROM_ISR() ：进入临界段（中断级）。</p>
</li>
<li><p>taskEXIT_CRITICAL_FROM_ISR()：退出临界段（中断级）。</p>
</li>
</ul>
<p>进入和退出临界段是成对使用的。每进入一次临界段，全局变量 uxCriticalNesting 都会加一，每调用一次退出临界段，uxCriticalNesting 减一，只有当<br>uxCriticalNesting 为 0 的时候才会调用函数<br>portENABLE_INTERRUPTS()使能中断。这确保了在存在多个临界段代码的情况下，不会因为某个临界段代码的退出而破坏其他临界段的保护。只有当所有的临界段代码都退出时，中断才会被重新使能。</p>
<h3 id="挂起和恢复任务调度器"><a href="#挂起和恢复任务调度器" class="headerlink" title="挂起和恢复任务调度器"></a>挂起和恢复任务调度器</h3><p>挂起和恢复任务调度器， 调用此函数不需要关闭中断：</p>
<ul>
<li><p>vTaskSuspendAll()：挂起任务调度器。</p>
</li>
<li><p>xTaskResumeAll()：恢复任务调度器。</p>
</li>
</ul>
<p>与临界区不同的是，挂起任务调度器时<strong>未关闭中断</strong>；这种方式仅仅防止了任务之间的资源争夺，中断仍然可以直接响应；挂起调度器的方法适用于临界区位于任务与任务之间的情况；这样既不需要延迟中断，同时又能确保临界区的安全性。</p>
<h2 id="FreeRTOS-中断管理实验（掌握）"><a href="#FreeRTOS-中断管理实验（掌握）" class="headerlink" title="FreeRTOS 中断管理实验（掌握）"></a>FreeRTOS 中断管理实验（掌握）</h2><h3 id="实验目标-3"><a href="#实验目标-3" class="headerlink" title="实验目标"></a>实验目标</h3><p>学会 FreeRTOS 中断管理：</p>
<ul>
<li><p>设置管理的优先级范围：5~15。</p>
</li>
<li><p>使用两个定时器，一个优先级为 4，一个优先级为 6。</p>
</li>
<li><p>两个定时器每 1s，打印一段字符串。</p>
</li>
<li><p>task1：按下 KEY1，关中断，按下 KEY2，开中断。</p>
<p>观察两个定时器的打印情况。</p>
</li>
</ul>
<h3 id="添加定时器"><a href="#添加定时器" class="headerlink" title="添加定时器"></a>添加定时器</h3><p>添加完定时器，重新注释掉 stm32f1xx_it.c 的 SVC_Handler 和 PendSV_Handler 函数。</p>
<h3 id="main-c-代码清单"><a href="#main-c-代码清单" class="headerlink" title="main.c 代码清单"></a>main.c 代码清单</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</span><br><span class="line">&#123;</span><br><span class="line">    if (htim-&gt;Instance == TIM2)</span><br><span class="line">    &#123;</span><br><span class="line">       printf(&quot;TIM2优先级为4,运行中...\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(htim-&gt;Instance == TIM3)</span><br><span class="line">    &#123;</span><br><span class="line">       printf(&quot;TIM3优先级为6,运行中...\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* USER CODE END 0 */</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN 2 */</span><br><span class="line">  HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line">  HAL_TIM_Base_Start_IT(&amp;htim3);</span><br><span class="line">  /* USER CODE END 2 */</span><br></pre></td></tr></table></figure>

<h3 id="FreeRTOSConfig-h-代码清单-3"><a href="#FreeRTOSConfig-h-代码清单-3" class="headerlink" title="FreeRTOSConfig.h 代码清单"></a>FreeRTOSConfig.h 代码清单</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*3. 中断嵌套行为相关配置 cm3内核:我们要求4个优先级位全部为抢占优先级位</span><br><span class="line">    最高优先级是 0</span><br><span class="line">    最低优先级是 15</span><br><span class="line">*/</span><br><span class="line">/* 设置 RTOS 内核自身使用的中断优先级。 一般设置为最低优先级, 不至于屏蔽其他优先级程序*/</span><br><span class="line">#define configKERNEL_INTERRUPT_PRIORITY (15 &lt;&lt; 4)</span><br><span class="line">/* 设置了 调用中断安全的 FreeRTOS API 函数的最高中断优先级。 FreeRTOS 的管理的最高优先级 */</span><br><span class="line">#define configMAX_SYSCALL_INTERRUPT_PRIORITY  (5 &lt;&lt; 4)</span><br><span class="line">/* 同上. 仅用于新版移植。 这两者是等效的。 */</span><br><span class="line">#define configMAX_API_CALL_INTERRUPT_PRIORITY   configMAX_SYSCALL_INTERRUPT_PRIORITY</span><br></pre></td></tr></table></figure>

<h3 id="freertos-demo-c-代码清单-3"><a href="#freertos-demo-c-代码清单-3" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li>任务配置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 启动任务函数 */</span><br><span class="line">#define START_TASK_PRIORITY 1</span><br><span class="line">#define START_TASK_STACK_DEPTH 128</span><br><span class="line">TaskHandle_t start_task_handler;</span><br><span class="line">void Start_Task(void *pvParameters);</span><br><span class="line"></span><br><span class="line">/* Task1 任务 配置 */</span><br><span class="line">#define TASK1_PRIORITY 2</span><br><span class="line">#define TASK1_STACK_DEPTH 128</span><br><span class="line">TaskHandle_t task1_handler;</span><br><span class="line">void Task1(void *pvParameters);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>入口函数</p>
</li>
<li><p>初始任务函数</p>
</li>
<li><p>task1 任务函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 开关中断</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task1(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t key = 0;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        key = Key_Detect();</span><br><span class="line">        if (key == KEY1_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            /* 关中断 */</span><br><span class="line">            printf(&quot;&gt;&gt;&gt;&gt;关中断.....\r\n&quot;);</span><br><span class="line">            portDISABLE_INTERRUPTS();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (key == KEY2_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            /* 开中断 */</span><br><span class="line">            printf(&quot;&gt;&gt;&gt;&gt;开中断.....\r\n&quot;);</span><br><span class="line">            portENABLE_INTERRUPTS();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* 为了观察实验现象，不要调用freertos的延时函数，底层会去开关中断，影响现象 */</span><br><span class="line">        // vTaskDelay(500);</span><br><span class="line">        /* 使用HAL_Delay前提：HAL时钟修改成其他定时器，并且中断优先级高于freertos的管理范围 */</span><br><span class="line">        HAL_Delay(500);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FreeRTOS-时间片调度"><a href="#FreeRTOS-时间片调度" class="headerlink" title="FreeRTOS 时间片调度"></a>FreeRTOS 时间片调度</h1><h2 id="时间片调度简介（熟悉）"><a href="#时间片调度简介（熟悉）" class="headerlink" title="时间片调度简介（熟悉）"></a>时间片调度简介（熟悉）</h2><p>在 FreeRTOS 中，同等优先级的任务会轮流分享相同的 CPU 时间，这个时间被称为时间片。在这里，一个时间片的长度等同于 SysTick 中断的周期。</p>
<h2 id="时间片调度实验演示（掌握）"><a href="#时间片调度实验演示（掌握）" class="headerlink" title="时间片调度实验演示（掌握）"></a>时间片调度实验演示（掌握）</h2><h3 id="实验目标-4"><a href="#实验目标-4" class="headerlink" title="实验目标"></a>实验目标</h3><p>理解 FreeRTOS 的时间片调度：</p>
<ul>
<li><p>start_task：用来创建其他的 2 个任务。</p>
</li>
<li><p>task1：通过串口打印 task1 的运行次数，设置任务优先级为 2。</p>
</li>
<li><p>task2：通过串口打印 task2 的运行次数，设置任务优先级为 2。</p>
</li>
</ul>
<p>为了更好观察现象，滴答定时器的中断频率设置为 50ms 中断一次（一个时间片）。</p>
<h3 id="FreeRTOSConfig-h-代码清单-4"><a href="#FreeRTOSConfig-h-代码清单-4" class="headerlink" title="FreeRTOSConfig.h 代码清单"></a>FreeRTOSConfig.h 代码清单</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define configUSE_TIME_SLICING 1</span><br><span class="line"></span><br><span class="line">#define configUSE_PREEMPTION 1</span><br><span class="line"></span><br><span class="line">#define configTICK_RATE_HZ ( ( TickType_t ) 20 )</span><br></pre></td></tr></table></figure>

<h3 id="freertos-demo-c-代码清单-4"><a href="#freertos-demo-c-代码清单-4" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li><p>任务配置</p>
</li>
<li><p>入口函数</p>
</li>
<li><p>初始任务函数</p>
</li>
<li><p>task1 任务函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 打印任务1执行次数</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task1(void * pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint16_t task1_count=0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        /* 临界区避免printf执行一半被打断 */</span><br><span class="line">        taskENTER_CRITICAL();</span><br><span class="line">        printf(&quot;task1运行次数=%d..\r\n&quot;,++task1_count);</span><br><span class="line">         // vTaskDelay(500); //为了观察时间片调度，不使用freertos的延时函数</span><br><span class="line">        HAL_Delay(10); // 使用该延时的前提：HAL时钟修改成其他定时器，并且中断优先级较高</span><br><span class="line">        taskEXIT_CRITICAL();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>task2 任务函数<br>同上</li>
</ol>
<h1 id="FreeRTOS-任务相关-API-函数"><a href="#FreeRTOS-任务相关-API-函数" class="headerlink" title="FreeRTOS 任务相关 API 函数"></a>FreeRTOS 任务相关 API 函数</h1><h2 id="FreeRTOS-任务相关-API-函数介绍（熟悉）"><a href="#FreeRTOS-任务相关-API-函数介绍（熟悉）" class="headerlink" title="FreeRTOS 任务相关 API 函数介绍（熟悉）"></a>FreeRTOS 任务相关 API 函数介绍（熟悉）</h2><p>任务相关的 API 主要如下：</p>
<hr>
<p>函数 描述</p>
<hr>
<p>uxTaskPriorityGet() 获取任务优先级</p>
<p>vTaskPrioritySet() 设置任务优先级</p>
<p>uxTaskGetNumberOfTasks() 获取系统中任务的数量</p>
<p>uxTaskGetSystemState() 获取所有任务状态信息</p>
<p>vTaskGetInfo() 获取指定单个的任务信息</p>
<p>xTaskGetCurrentTaskHandle() 获取当前任务的任务句柄</p>
<p>xTaskGetHandle() 根据任务名获取该任务的任务句柄</p>
<p>uxTaskGetStackHighWaterMark() 获取任务的任务栈历史剩余最小值</p>
<p>eTaskGetState() 获取任务状态</p>
<p>vTaskList() 以”表格”形式获取所有任务的信息</p>
<p>vTaskGetRunTimeStats() 获取任务的运行时间</p>
<hr>
<p>官网：<a target="_blank" rel="noopener" href="https://www.freertos.org/zh-cn-cmn-s/Documentation/02-Kernel/04-API-references/03-Task-utilities/00-Task-utilities">https://www.freertos.org/zh-cn-cmn-s/Documentation/02-Kernel/04-API-references/03-Task-utilities/00-Task-utilities</a></p>
<h2 id="任务状态查询-API-函数实验（掌握）"><a href="#任务状态查询-API-函数实验（掌握）" class="headerlink" title="任务状态查询 API 函数实验（掌握）"></a>任务状态查询 API 函数实验（掌握）</h2><h3 id="实验目标-5"><a href="#实验目标-5" class="headerlink" title="实验目标"></a>实验目标</h3><p>学会使用 FreeRTOS 任务状态查询相关 API 函数：</p>
<ul>
<li><p>start_task：用来创建其他的 2 个任务。</p>
</li>
<li><p>task1：LED1 每 500ms 闪烁一次，提示程序正在运行。</p>
</li>
<li><p>task2：用于展示任务状态查询相关 API 函数的使用。</p>
</li>
</ul>
<h3 id="FreeRTOSConfig-h-代码清单-5"><a href="#FreeRTOSConfig-h-代码清单-5" class="headerlink" title="FreeRTOSConfig.h 代码清单"></a>FreeRTOSConfig.h 代码清单</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define INCLUDE_xTaskGetSchedulerState 1</span><br><span class="line"></span><br><span class="line">#define configUSE_TRACE_FACILITY 1</span><br><span class="line"></span><br><span class="line">#define configUSE_STATS_FORMATTING_FUNCTIONS 1</span><br><span class="line"></span><br><span class="line">#define INCLUDE_xTaskGetHandle 1</span><br><span class="line"></span><br><span class="line">#define INCLUDE_uxTaskGetStackHighWaterMark 1</span><br><span class="line"></span><br><span class="line">#define INCLUDE_eTaskGetState 1</span><br></pre></td></tr></table></figure>

<h3 id="freertos-demo-c-代码清单-5"><a href="#freertos-demo-c-代码清单-5" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li><p>任务配置</p>
</li>
<li><p>入口函数</p>
</li>
<li><p>初始函数</p>
</li>
<li><p>task1 任务函数</p>
</li>
<li><p>task2 任务函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 查询任务信息</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">char task_info[500];</span><br><span class="line">void Task2(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    UBaseType_t task_priority = 0;</span><br><span class="line">    UBaseType_t task_num = 0;</span><br><span class="line">    UBaseType_t task_num2 = 0;</span><br><span class="line">    TaskStatus_t task_status[4] = 0;</span><br><span class="line">    TaskStatus_t task_status2[1] = 0;</span><br><span class="line">    TaskHandle_t task_handle = 0;</span><br><span class="line">    UBaseType_t task_stack_remain_min = 0;</span><br><span class="line">    eTaskState task_state = 0;</span><br><span class="line"></span><br><span class="line">    /* 查询任务优先级 */</span><br><span class="line">    task_priority = uxTaskPriorityGet(task1_handler);</span><br><span class="line">    printf(&quot;task1任务优先级=%d....\r\n&quot;, task_priority);</span><br><span class="line">    task_priority = uxTaskPriorityGet(task2_handler);</span><br><span class="line">    printf(&quot;task2任务优先级=%d....\r\n&quot;, task_priority);</span><br><span class="line"></span><br><span class="line">    /* 设置任务优先级 */</span><br><span class="line">    vTaskPrioritySet(task1_handler, 4);</span><br><span class="line">    task_priority = uxTaskPriorityGet(task1_handler);</span><br><span class="line">    printf(&quot;task1任务优先级=%d....\r\n&quot;, task_priority);</span><br><span class="line"></span><br><span class="line">    /* 查询任务数量：包含启动调度器时底层启动的任务 */</span><br><span class="line">    task_num = uxTaskGetNumberOfTasks();</span><br><span class="line">    printf(&quot;任务数量=%d....\r\n&quot;, task_num);</span><br><span class="line"></span><br><span class="line">    /* 获取系统状态 */</span><br><span class="line">    task_num2 = uxTaskGetSystemState(task_status, task_num, NULL);</span><br><span class="line">    printf(&quot;任务名\t任务编号\t任务优先级\r\n&quot;);</span><br><span class="line">    for (uint8_t i = 0; i &lt; task_num2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%s\t%d\t%d\r\n&quot;,</span><br><span class="line">               task_status[i].pcTaskName,</span><br><span class="line">               task_status[i].xTaskNumber,</span><br><span class="line">               task_status[i].uxCurrentPriority);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取单个任务信息 */</span><br><span class="line">    vTaskGetInfo(task1_handler,</span><br><span class="line">                 task_status2,</span><br><span class="line">                 pdTRUE,</span><br><span class="line">                 eInvalid);</span><br><span class="line">    printf(&quot;任务名：%s\r\n&quot;, task_status2-&gt;pcTaskName);</span><br><span class="line">    printf(&quot;任务编号：%d\r\n&quot;, task_status2-&gt;xTaskNumber);</span><br><span class="line">    printf(&quot;任务优先级：%d\r\n&quot;, task_status2-&gt;uxCurrentPriority);</span><br><span class="line">    printf(&quot;任务状态：%d\r\n&quot;, task_status2-&gt;eCurrentState);</span><br><span class="line"></span><br><span class="line">    /* 根据任务名获取任务句柄 */</span><br><span class="line">    task_handle = xTaskGetHandle(&quot;Task1&quot;);</span><br><span class="line">    printf(&quot;获取Task1任务句柄:%#x\r\n&quot;,task_handle);</span><br><span class="line">    printf(&quot;Task1任务句柄:%#x\r\n&quot;,task1_handler);</span><br><span class="line"></span><br><span class="line">    /* 获取指定任务的任务栈历史最小剩余值 */</span><br><span class="line">    task_stack_remain_min = uxTaskGetStackHighWaterMark( task2_handler );</span><br><span class="line">    printf(&quot;task2任务栈历史最小值=%d\r\n&quot;,task_stack_remain_min);</span><br><span class="line"></span><br><span class="line">    /* 获取指定任务的状态 */</span><br><span class="line">    task_state = eTaskGetState( task2_handler );</span><br><span class="line">    printf(&quot;task2当前任务状态=%d\r\n&quot;,task_state);</span><br><span class="line"></span><br><span class="line">    /* 以表格形式获取系统中任务的信息 */</span><br><span class="line">    vTaskList(task_info);</span><br><span class="line">    printf(&quot;%s\r\n&quot;,task_info);</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskDelay(100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务时间统计-API-函数实验（掌握）"><a href="#任务时间统计-API-函数实验（掌握）" class="headerlink" title="任务时间统计 API 函数实验（掌握）"></a>任务时间统计 API 函数实验（掌握）</h2><h3 id="实验目标-6"><a href="#实验目标-6" class="headerlink" title="实验目标"></a>实验目标</h3><p>学会使用 FreeRTOS 任务运行时间统计相关 API 函数：</p>
<ul>
<li><p>start_task：用来创建其他的 2 个任务。</p>
</li>
<li><p>task1：LED1 每 500ms 闪烁一次，提示程序正在运行。</p>
</li>
<li><p>task2：用于展示任务运行时间统计相关 API 函数的使用。</p>
</li>
</ul>
<h3 id="tim-c-代码清单"><a href="#tim-c-代码清单" class="headerlink" title="tim.c 代码清单"></a>tim.c 代码清单</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void MX_TIM2_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">……</span><br><span class="line">  htim2.Instance = TIM2;</span><br><span class="line">  htim2.Init.Prescaler = 72-1;</span><br><span class="line">  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;</span><br><span class="line">  htim2.Init.Period = 10-1;</span><br><span class="line">  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;</span><br><span class="line">  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="main-c-代码清单-1"><a href="#main-c-代码清单-1" class="headerlink" title="main.c 代码清单"></a>main.c 代码清单</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line">volatile unsigned long ulHighFrequencyTimerTicks;</span><br><span class="line">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</span><br><span class="line">&#123;</span><br><span class="line">    if (htim-&gt;Instance == TIM2)</span><br><span class="line">    &#123;</span><br><span class="line">        ulHighFrequencyTimerTicks++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* USER CODE END 0 */</span><br></pre></td></tr></table></figure>

<h3 id="FreeRTOSConfig-h-代码清单-6"><a href="#FreeRTOSConfig-h-代码清单-6" class="headerlink" title="FreeRTOSConfig.h 代码清单"></a>FreeRTOSConfig.h 代码清单</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* 运行时间和任务状态统计相关定义 */</span><br><span class="line">#define configGENERATE_RUN_TIME_STATS    1      /* 1: 使能任务运行时间统计功能, 默认: 0 */</span><br><span class="line">#if configGENERATE_RUN_TIME_STATS</span><br><span class="line">extern volatile unsigned long ulHighFrequencyTimerTicks;</span><br><span class="line">#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() ( ulHighFrequencyTimerTicks = 0UL )</span><br><span class="line">#define portGET_RUN_TIME_COUNTER_VALUE()    ulHighFrequencyTimerTicks</span><br><span class="line">#endif</span><br><span class="line">#define configUSE_TRACE_FACILITY               1</span><br><span class="line">#define configUSE_STATS_FORMATTING_FUNCTIONS   1</span><br></pre></td></tr></table></figure>

<ul>
<li><p>portCONFIGURE_TIMER_FOR_RUNTIME_STATE()：用于初始化用于配置任务运行时间统计的时基定时器。它的时间精度需要比<br>tick 中断具有更高的精度，建议 10 到 100 倍。</p>
</li>
<li><p>portGET_RUN_TIME_COUNTER_VALUE()：返回该定时器的计数值，即当前已运行的时间。</p>
</li>
</ul>
<p>参数说明：<a target="_blank" rel="noopener" href="https://freertos.org/zh-cn-cmn-s/rtos-run-time-stats.html">https://freertos.org/zh-cn-cmn-s/rtos-run-time-stats.html</a></p>
<h3 id="freertos-demo-c-代码清单-6"><a href="#freertos-demo-c-代码清单-6" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li><p>任务配置</p>
</li>
<li><p>入口函数</p>
</li>
<li><p>初始任务函数</p>
</li>
<li><p>task1 任务函数</p>
</li>
<li><p>task2 任务函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 按下KEY1，打印任务运行时间</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">char task_stat[500];</span><br><span class="line">void Task2(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t key = 0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        key = Key_Detect();</span><br><span class="line">        if(key == KEY1_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            vTaskGetRunTimeStats(task_stat);</span><br><span class="line">            printf(&quot;%s\r\n&quot;,task_stat);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h1 id="FreeRTOS-时间管理"><a href="#FreeRTOS-时间管理" class="headerlink" title="FreeRTOS 时间管理"></a>FreeRTOS 时间管理</h1><h2 id="延时函数介绍（了解）"><a href="#延时函数介绍（了解）" class="headerlink" title="延时函数介绍（了解）"></a>延时函数介绍（了解）</h2><ul>
<li><p>vTaskDelay()：相对延时。从执行 vTaskDelay()函数开始，直到指定延时的时间结束。</p>
</li>
<li><p>xTaskDelayUntil()：绝对延时。将整个任务的运行周期视为一个整体，适用于需要以固定频率定期执行的任务。</p>
</li>
</ul>
<p>假设有一个定时器，每隔 1 秒触发一次，希望在每次触发时执行某个任务。如果使用 vTaskDelay<br>来实现，那么你只能实现任务每秒执行一次，而不能确保任务在每秒的开始时刻执行。但如果你使用<br>xTaskDelayUntil，你可以指定任务在每秒的开始时刻执行，即使任务执行的时间不同。</p>
<h1 id="FreeRTOS-消息队列"><a href="#FreeRTOS-消息队列" class="headerlink" title="FreeRTOS 消息队列"></a>FreeRTOS 消息队列</h1><h2 id="队列简介（了解）"><a href="#队列简介（了解）" class="headerlink" title="队列简介（了解）"></a>队列简介（了解）</h2><p>队列是任务间通信的主要形式。<br>它们可以用于在<strong>任务之间</strong>以及<strong>中断和任务之间</strong>发送消息。</p>
<p>队列是线程安全的数据结构，任务可以通过队列在彼此之间传递数据。有以下关键特点：</p>
<ul>
<li><p>FIFO 顺序：队列采用先进先出 (FIFO) 的顺序，即先发送的消息会被先接收。</p>
</li>
<li><p>线程安全：队列操作是原子的，确保在多任务环境中的数据完整性。</p>
</li>
<li><p>阻塞和非阻塞操作：任务可以通过阻塞或非阻塞的方式发送和接收消息。如果队列满了或者为空，任务可以选择等待直到有空间或者数据可用，或者立即返回。</p>
</li>
<li><p>优先级继承：FreeRTOS<br>支持基于优先级的消息传递，确保高优先级任务在队列操作期间不会被低优先级任务阻塞。</p>
</li>
<li><p>可变长度项：队列中的项可以是不同长度的数据块，而不是固定大小。</p>
</li>
</ul>
<p>使用队列，任务可以通过发送消息来共享信息，从而更好地协调和同步系统中的不同部分。</p>
<h2 id="队列相关-API-函数介绍（熟悉）"><a href="#队列相关-API-函数介绍（熟悉）" class="headerlink" title="队列相关 API 函数介绍（熟悉）"></a>队列相关 API 函数介绍（熟悉）</h2><h3 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h3><hr>
<p>函数 描述</p>
<hr>
<p>xQueueCreate() 动态方式创建队列</p>
<p>xQueueCreateStatic() 静态方式创建队列</p>
<hr>
<p>动态创建队列时，FreeRTOS 会在运行时从其内置的堆中为队列分配所需的内存空间。这种方式更加灵活，允许系统根据需要动态调整内存。</p>
<p>相反，静态创建队列要求用户在编译时手动为队列分配内存，而不依赖于 FreeRTOS 的堆管理。这使得内存的分配在编写代码时就能确定，因此在资源受限或对内存使用有严格要求的嵌入式系统中可能更为合适。</p>
<p>总体而言，动态创建提供了更大的灵活性，但可能会增加堆管理的复杂性。静态创建则更为直观，适用于在编译时就能确定内存分配的情况。选择使用哪种方式通常取决于系统的需求和设计考虑。</p>
<h3 id="往队列写入消息"><a href="#往队列写入消息" class="headerlink" title="往队列写入消息"></a>往队列写入消息</h3><hr>
<p>函数 描述</p>
<hr>
<p>xQueueSend() 往队列的尾部写入消息</p>
<p>xQueueSendToBack() 同 xQueueSend()</p>
<p>xQueueSendToFront() 往队列的头部写入消息</p>
<p>xQueueOverwrite() 覆写队列消息（只用于队列长度为 1 的情况）</p>
<p>xQueueSendFromISR() 在中断中往队列的尾部写入消息</p>
<p>xQueueSendToBackFromISR() 同 xQueueSendFromISR()</p>
<p>xQueueSendToFrontFromISR() 在中断中往队列的头部写入消息</p>
<p>xQueueOverwriteFromISR() 在中断中覆写队列消息（只用于队列长度为 1<br>的情况）</p>
<hr>
<h3 id="从队列读取消息"><a href="#从队列读取消息" class="headerlink" title="从队列读取消息"></a>从队列读取消息</h3><hr>
<p>函数 描述</p>
<hr>
<p>xQueueReceive() 从队列头部读取消息，并删除消息</p>
<p>xQueuePeek() 从队列头部读取消息</p>
<p>xQueueReceiveFromISR() 在中断中从队列头部读取消息，并删除消息</p>
<p>xQueuePeekFromISR() 在中断中从队列头部读取消息</p>
<hr>
<h2 id="队列操作实验（掌握）"><a href="#队列操作实验（掌握）" class="headerlink" title="队列操作实验（掌握）"></a>队列操作实验（掌握）</h2><h3 id="实验目标-7"><a href="#实验目标-7" class="headerlink" title="实验目标"></a>实验目标</h3><p>学习使用 FreeRTOS 的队列相关函数，包括创建队列、入队和出队操作：</p>
<ul>
<li><p>start_task：用来创建其他的 3 个任务。</p>
</li>
<li><p>task1：当按键 key1 或 key2 按下，将键值拷贝到队列 queue1（入队）；当按键 key3 按下，将传输大数据，这里拷贝大数据的地址到队列 big_queue 中。</p>
</li>
<li><p>task2：读取队列 queue1 中的消息（出队），打印出接收到的键值。</p>
</li>
<li><p>task3：从队列 big_queue 读取大数据地址，通过地址访问大数据。</p>
</li>
</ul>
<h3 id="freertos-demo-c-代码清单-7"><a href="#freertos-demo-c-代码清单-7" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li>引入队列头文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include \&quot;queue.h\&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>任务配置</p>
</li>
<li><p>入口函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t queue1;    /* 小数据句柄 */</span><br><span class="line">QueueHandle_t big_queue; /* 大数据句柄 */</span><br><span class="line">char buff[100] = &#123;&quot;大大大fdahjk324hjkhfjksdahjk#$@!@#jfaskdfhjka&quot;&#125;;</span><br><span class="line">/**</span><br><span class="line"> * @description: FreeRTOS入口函数：创建任务函数并开始调度</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void FreeRTOS_Start(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* 创建queue1队列 */</span><br><span class="line">    queue1 = xQueueCreate(2, sizeof(uint8_t));</span><br><span class="line">    if (queue1 != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;queue1队列创建成功\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;queue1队列创建失败\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /* 创建big_queue队列 */</span><br><span class="line">    big_queue = xQueueCreate(1, sizeof(char *));</span><br><span class="line">    if (big_queue != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;big_queue队列创建成功\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;big_queue队列创建失败\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xTaskCreate((TaskFunction_t)Start_Task,</span><br><span class="line">                (char *)&quot;Start_Task&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE)START_TASK_STACK_DEPTH,</span><br><span class="line">                (void *)NULL,</span><br><span class="line">                (UBaseType_t)START_TASK_PRIORITY,</span><br><span class="line">                (TaskHandle_t *)&amp;start_task_handler);</span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>初始任务函数</p>
</li>
<li><p>task1 任务函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 入队</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task1(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t key = 0;</span><br><span class="line">    char *buf;</span><br><span class="line">    BaseType_t err = 0;</span><br><span class="line">    buf = &amp;buff[0];</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        key = Key_Detect();</span><br><span class="line">        if (key == KEY1_PRESS || key == KEY2_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            err = xQueueSend(queue1, &amp;key, portMAX_DELAY);</span><br><span class="line">            if (err != pdTRUE)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;queue1队列发送失败\r\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (key == KEY3_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            err = xQueueSend(big_queue, &amp;buf, portMAX_DELAY);</span><br><span class="line">            if (err != pdTRUE)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;big_queue队列发送失败\r\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>task2 任务函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 小数据出队</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task2(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t key = 0;</span><br><span class="line">    BaseType_t err = 0;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        err = xQueueReceive(queue1, &amp;key, portMAX_DELAY);</span><br><span class="line">        if (err != pdTRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;queue1队列读取失败\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;queue1读取队列成功，数据：%d\r\n&quot;, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>task3 任务函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 大数据出队</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task3(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    char *buf;</span><br><span class="line">    BaseType_t err = 0;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        err = xQueueReceive(big_queue, &amp;buf, portMAX_DELAY);</span><br><span class="line">        if (err != pdTRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;big_queue队列读取失败\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;数据：%s\r\n&quot;, buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><h2 id="信号量的简介（了解）"><a href="#信号量的简介（了解）" class="headerlink" title="信号量的简介（了解）"></a>信号量的简介（了解）</h2><p>FreeRTOS 中的信号量是一种用于任务间同步和资源管理的机制。信号量可以是二进制的（只能取 0 或 1）也可以是计数型的（可以是任意正整数）。信号量的基本操作包括”获取”和”释放”。</p>
<p>比如动车上的卫生间，一个卫生间同时只能容纳一个人，由指示灯来表示是否有人在使用。当我们想使用卫生间的时候，有如下过程：</p>
<ol>
<li><p>判断卫生间是否有人使用（判断信号量是否有资源）</p>
</li>
<li><p>卫生间空闲（信号量有资源），那么就可以直接进入卫生间（获取信号量成功）</p>
</li>
<li><p>卫生间使用中（信号量没有资源），那么这个人可以选择不上卫生间（获取信号量失败），也可以在门口等待（任务阻塞）</p>
</li>
</ol>
<p>信号量与队列的区别如下：</p>
<hr>
<p>信号量 队列</p>
<hr>
<p>主要用于管理对共享资源的访问，确保在同一时刻只有一个任务可以访问共享资源 用于任务之间的数据通信，通过在任务之间传递消息，实现信息的传递和同步。</p>
<p>可以是二进制信号量（Binary Semaphore）或计数信号量（Counting Semaphore） 存储和传递消息的数据结构，任务可以发送消息到队列，也可以从队列接收消息。</p>
<p>适用于对资源的互斥访问，控制任务的执行顺序，或者限制同时访问某一资源的任务数量。 适用于在任务之间传递数据，实现解耦和通信。</p>
<hr>
<h2 id="二值信号量（熟悉）"><a href="#二值信号量（熟悉）" class="headerlink" title="二值信号量（熟悉）"></a>二值信号量（熟悉）</h2><p>二值信号量（Binary<br>Semaphore）是一种特殊类型的信号量，它只有两个可能的值：0 和 1。这种信号量主要用于实现对共享资源的互斥访问或者任务之间的同步。</p>
<ul>
<li><p>两个状态：<br>二值信号量只能处于两个状态之一，通常用 0 和 1 表示。当信号量的值为 0 时，表示资源不可用；当值为 1 时，表示资源可用。</p>
</li>
<li><p>互斥访问：<br>常用于控制对共享资源的互斥访问，确保在同一时刻只有一个任务可以访问共享资源。任务在访问资源之前会尝试获取信号量，成功则继续执行，失败则等待。</p>
</li>
<li><p>任务同步：<br>也可以用于任务之间的同步，例如一个任务等待另一个任务完成某个操作。</p>
</li>
</ul>
<p>信号量 API 函数允许指定阻塞时间。<br>阻塞时间表示当一个任务试图”获取”信号量时，<br>如果信号不是立即可用，那么该任务进入阻塞状态的最大 “tick” 数。 如果<br>多个任务在同一个信号量上阻塞，那么具有<strong>最高优先级的任务</strong>将在下次信号量可用时<strong>最先解除阻塞</strong><br>。</p>
<p>可将二进制信号量视为仅能<strong>容纳一个项目的队列</strong>。<br>因此，队列只能为空或满（因此称为二进制）。 使用队列的任务和中断<br>不在乎队列容纳的是什么——它们只想知道队列是空的还是满的。 可以<br>利用该机制来同步任务和中断。</p>
<p>二值信号量相关函数：</p>
<hr>
<p>函数 描述</p>
<hr>
<p>xSemaphoreCreateBinary() 使用动态方式创建二值信号量</p>
<p>xSemaphoreCreateBinaryStatic() 使用静态方式创建二值信号量</p>
<p>xSemaphoreGive() 释放信号量</p>
<p>xSemaphoreGiveFromISR() 在中断中释放信号量</p>
<p>xSemaphoreTake() 获取信号量</p>
<p>xSemaphoreTakeFromISR() 在中断中获取信号量</p>
<hr>
<h2 id="二值信号量实验（掌握）"><a href="#二值信号量实验（掌握）" class="headerlink" title="二值信号量实验（掌握）"></a>二值信号量实验（掌握）</h2><h3 id="实验目标-8"><a href="#实验目标-8" class="headerlink" title="实验目标"></a>实验目标</h3><p>学习使用 FreeRTOS 的二值信号量相关函数：</p>
<ul>
<li><p>start_task：用来创建其他的 2 个任务。</p>
</li>
<li><p>task1：用于按键扫描，当检测到按键 KEY1 被按下时，释放二值信号量。</p>
</li>
<li><p>task2：获取二值信号量，当成功获取后打印提示信息。</p>
</li>
</ul>
<h3 id="freertos-demo-c-代码清单-8"><a href="#freertos-demo-c-代码清单-8" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li>引入信号量头文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include \&quot;semphr.h\&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>任务配置</p>
</li>
<li><p>入口函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t semphore_handle;</span><br><span class="line">/**</span><br><span class="line"> * @description: FreeRTOS入口函数：创建任务函数并开始调度</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void FreeRTOS_Start(void)</span><br><span class="line">&#123;</span><br><span class="line">    semphore_handle = xSemaphoreCreateBinary();</span><br><span class="line">    if (semphore_handle != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;二值信号量创建成功\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    xTaskCreate((TaskFunction_t)Start_Task,</span><br><span class="line">                (char *)&quot;Start_Task&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE)START_TASK_STACK_DEPTH,</span><br><span class="line">                (void *)NULL,</span><br><span class="line">                (UBaseType_t)START_TASK_PRIORITY,</span><br><span class="line">                (TaskHandle_t *)&amp;start_task_handler);</span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>初始任务函数</p>
</li>
<li><p>task1 任务函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 释放二值信号量</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task1(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t key = 0;</span><br><span class="line">    BaseType_t err;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        key = Key_Detect();</span><br><span class="line">        if (key == KEY1_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            if (semphore_handle != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                err = xSemaphoreGive(semphore_handle);</span><br><span class="line">                if (err == pdPASS)</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;信号量释放成功\r\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    printf(&quot;信号量释放失败\r\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>task2 任务函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 获取二值信号量</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task2(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t i = 0;</span><br><span class="line">    BaseType_t err;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        /* 一直等待获取信号量 */</span><br><span class="line">        err = xSemaphoreTake(semphore_handle, portMAX_DELAY);</span><br><span class="line">        if (err == pdTRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;获取信号量成功\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;已超时%d\r\n&quot;, ++i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计数型信号量（熟悉）"><a href="#计数型信号量（熟悉）" class="headerlink" title="计数型信号量（熟悉）"></a>计数型信号量（熟悉）</h2><p>正如二进制信号量可以被认为是长度为 1<br>的队列那样，计数信号量也可以被认为是长度大于 1 的队列。<br>信号量的用户对存储在队列中的数据不感兴趣，他们只关心队列是否为空。</p>
<p>计数信号量通常用于两种情况：</p>
<ol>
<li><p>事件计数：在此使用方案中，每次事件发生时，事件处理程序将”给出”一个信号量（信号量计数值递增）<br>，并且<br>处理程序任务每次处理事件（信号量计数值递减）时”获取”一个信号量。因此，计数值是<br>已发生的事件数与已处理的事件数之间的差值。在这种情况下，<br>创建信号量时计数值可以为零。</p>
</li>
<li><p>资源管理：在此使用情景中，计数值表示可用资源的数量。要获得对资源的控制权，任务必须首先获取<br>一个信号量——同时递减信号量计数值。当计数值达到零时，表示没有空闲资源可用。当任务使用完资源时，<br>“返还”一个信号量——同时递增信号量计数值。在这种情况下，<br>创建信号量时计数值可以等于最大计数值。</p>
</li>
</ol>
<p>计数型信号量相关函数：</p>
<hr>
<p>函数 描述</p>
<hr>
<p>xSemaphoreCreateCounting() 使用动态方法创建计数型信号量。</p>
<p>xSemaphoreCreateCountingStatic() 使用静态方法创建计数型信号量</p>
<p>uxSemaphoreGetCount() 获取信号量的计数值</p>
<hr>
<h2 id="计数型信号量实验（掌握）"><a href="#计数型信号量实验（掌握）" class="headerlink" title="计数型信号量实验（掌握）"></a>计数型信号量实验（掌握）</h2><h3 id="实验目标-9"><a href="#实验目标-9" class="headerlink" title="实验目标"></a>实验目标</h3><p>学习使用 FreeRTOS 的计数型信号量相关函数：</p>
<ul>
<li><p>start_task：用来创建其他的 2 个任务。</p>
</li>
<li><p>task1：用于按键扫描，当检测到按键 KEY1 被按下时，释放计数型信号量。</p>
</li>
<li><p>task2：每过一秒获取一次计数型信号量，当成功获取后打印信号量计数值。</p>
</li>
</ul>
<h3 id="FreeRTOSConfig-h-代码清单-7"><a href="#FreeRTOSConfig-h-代码清单-7" class="headerlink" title="FreeRTOSConfig.h 代码清单"></a>FreeRTOSConfig.h 代码清单</h3><p>#define configUSE_COUNTING_SEMAPHORES 1</p>
<h3 id="freertos-demo-c-代码清单-9"><a href="#freertos-demo-c-代码清单-9" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li>引入信号量头文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include \&quot;semphr.h\&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>任务配置</p>
</li>
<li><p>入口函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t count_semphore_handle;</span><br><span class="line">/**</span><br><span class="line"> * @description: FreeRTOS入口函数：创建任务函数并开始调度</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void FreeRTOS_Start(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* 创建计数型信号量 */</span><br><span class="line">    count_semphore_handle = xSemaphoreCreateCounting(100 , 0);</span><br><span class="line">    if(count_semphore_handle != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;计数型信号量创建成功\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    xTaskCreate((TaskFunction_t)Start_Task,</span><br><span class="line">                (char *)&quot;Start_Task&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE)START_TASK_STACK_DEPTH,</span><br><span class="line">                (void *)NULL,</span><br><span class="line">                (UBaseType_t)START_TASK_PRIORITY,</span><br><span class="line">                (TaskHandle_t *)&amp;start_task_handler);</span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>初始任务函数</p>
</li>
<li><p>task1 任务函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 释放计数型信号量</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task1(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t key = 0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        key = Key_Detect();</span><br><span class="line">        if(key == KEY1_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            if(count_semphore_handle != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                /* 释放信号量 */</span><br><span class="line">                xSemaphoreGive(count_semphore_handle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>task2 任务函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 获取计数型信号量</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task2(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t err = 0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        /* 一直等待获取信号量 */</span><br><span class="line">        err = xSemaphoreTake(count_semphore_handle,portMAX_DELAY);</span><br><span class="line">        if(err == pdTRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;信号量的计数值=%d\r\n&quot;,(int)uxSemaphoreGetCount(count_semphore_handle));</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优先级翻转简介（熟悉）"><a href="#优先级翻转简介（熟悉）" class="headerlink" title="优先级翻转简介（熟悉）"></a>优先级翻转简介（熟悉）</h2><p>优先级翻转是一个在实时系统中可能出现的问题，特别是在多任务环境中。该问题指的是一个较低优先级的任务阻塞了一个较高优先级任务的执行，从而导致高优先级任务无法及时完成。</p>
<p>典型的优先级翻转场景如下：</p>
<ul>
<li><p>任务 A（高优先级）：拥有高优先级，需要访问共享资源，比如一个关键数据结构。</p>
</li>
<li><p>任务 B（低优先级）：拥有低优先级，目前正在访问该共享资源。</p>
</li>
<li><p>任务 C（中优先级）：位于任务 A 和任务 B 之间，具有介于两者之间的优先级。</p>
</li>
</ul>
<p>具体流程如下：</p>
<ol>
<li><p>任务 A 开始执行，但由于任务 B 正在访问共享资源，任务 A 被阻塞等待。</p>
</li>
<li><p>任务 C 获得执行权，由于优先级高于任务 B，它可以抢占任务 B。</p>
</li>
<li><p>任务 C 执行完成后，任务 B 被解除阻塞，开始执行，完成后释放了共享资源。</p>
</li>
<li><p>任务 A 重新获取执行权，继续执行。</p>
</li>
</ol>
<p>这个过程中，任务 A 因为资源被占用而被阻塞，而任务 B 却被中优先级的任务 C 抢占，导致任务 B 无法及时完成。这种情况称为优先级翻转，因为任务 C 的介入翻转了高优先级任务 A 的执行顺序。</p>
<h2 id="互斥信号量（熟悉）"><a href="#互斥信号量（熟悉）" class="headerlink" title="互斥信号量（熟悉）"></a>互斥信号量（熟悉）</h2><p>互斥信号量是包含优先级继承机制的二进制信号量。二进制信号量能更好实现实现同步（任务间或任务与中断之间），<br>而互斥信号量有助于更好实现简单互斥（即相互排斥）。</p>
<p>优先级继承是一种解决实时系统中任务调度引起的优先级翻转问题的机制。在具体的任务调度中，当一个高优先级任务等待一个低优先级任务所持有的资源时，系统会提升低优先级任务的优先级，以避免高优先级任务长时间等待的情况。</p>
<p>优先级继承无法完全解决优先级翻转，只是在某些情况下将影响降至最低。</p>
<p><strong>不能在中断</strong>中使用互斥信号量，原因如下：</p>
<ul>
<li><p>互斥信号量使用的优先级继承机制要求从任务中（而不是从中断中）获取和释放互斥信号量。</p>
</li>
<li><p>中断无法保持阻塞来等待一个被互斥信号量保护的资源。</p>
</li>
</ul>
<p>互斥信号量相关函数：</p>
<hr>
<p>函数 描述</p>
<hr>
<p>xSemaphoreCreateMutex() 使用动态方法创建互斥信号量。</p>
<p>xSemaphoreCreateMutexStatic() 使用静态方法创建互斥信号量。</p>
<hr>
<p>互斥信号量的获取和释放函数与二值信号量的相应函数相似，但有一个重要的区别：互斥信号量不支持在中断服务程序中直接调用。注意，当创建互斥信号量时，系统会自动进行一次信号量的释放操作。</p>
<h2 id="互斥信号量实验（掌握）"><a href="#互斥信号量实验（掌握）" class="headerlink" title="互斥信号量实验（掌握）"></a>互斥信号量实验（掌握）</h2><h3 id="实验目标-10"><a href="#实验目标-10" class="headerlink" title="实验目标"></a>实验目标</h3><p>在前面优先级翻转实验的案例中，通过互斥信号量来解决优先级翻转问题：</p>
<p>信号量函数改成互斥信号量，通过串口打印提示信息。</p>
<h3 id="FreeRTOSConfig-h-代码清单-8"><a href="#FreeRTOSConfig-h-代码清单-8" class="headerlink" title="FreeRTOSConfig.h 代码清单"></a>FreeRTOSConfig.h 代码清单</h3><p>#define configUSE_MUTEXES 1</p>
<h3 id="freertos-demo-c-代码清单-10"><a href="#freertos-demo-c-代码清单-10" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li>引入信号量头文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include \&quot;semphr.h\&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>任务配置</p>
</li>
<li><p>入口函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t mutex_semphore_handle;</span><br><span class="line">/**</span><br><span class="line"> * @description: FreeRTOS入口函数：创建任务函数并开始调度</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void FreeRTOS_Start(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* 创建互斥信号量，并且主动释放一次信号量 */</span><br><span class="line">    mutex_semphore_handle = xSemaphoreCreateMutex();</span><br><span class="line">    if (mutex_semphore_handle != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;互斥信号量创建成功\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xTaskCreate((TaskFunction_t)Start_Task,</span><br><span class="line">                (char *)&quot;Start_Task&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE)START_TASK_STACK_DEPTH,</span><br><span class="line">                (void *)NULL,</span><br><span class="line">                (UBaseType_t)START_TASK_PRIORITY,</span><br><span class="line">                (TaskHandle_t *)&amp;start_task_handler);</span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>初始任务函数</p>
</li>
<li><p>低优先级任务函数</p>
</li>
<li><p>中优先级任务函数</p>
</li>
<li><p>高优先级任务函数</p>
</li>
</ol>
<h1 id="队列集"><a href="#队列集" class="headerlink" title="队列集"></a>队列集</h1><h2 id="队列集简介（了解）"><a href="#队列集简介（了解）" class="headerlink" title="队列集简介（了解）"></a>队列集简介（了解）</h2><p>队列集（Queue Set）是 FreeRTOS<br>中的一种数据结构，用于管理多个队列。它提供了一种有效的方式，通过单个 API<br>调用来操作和访问一组相关的队列。</p>
<p>在多任务系统中，任务之间可能需要共享数据，而这些数据可能存储在不同的队列中。队列集的作用就是为了更方便地管理这些相关队列，使得任务能够轻松地访问和处理多个队列的数据。</p>
<p>队列集的特点和用法：</p>
<ul>
<li><p>集中管理多个队列：队列集允许你将多个相关联的队列组织在一起，方便集中管理。</p>
</li>
<li><p>单一 API 调用：通过单一的 API<br>调用，任务可以同时操作多个队列，而无需分别处理每个队列。</p>
</li>
<li><p>简化任务代码：对于需要处理多个相关队列的任务，使用队列集可以简化代码，提高可读性和维护性。</p>
</li>
<li><p>提高系统效率：在需要协同工作的任务之间共享和传递数据时，队列集可以提高系统的效率。</p>
</li>
<li><p>协同工作：任务可以更方便地协同工作，共享数据，实现更复杂的任务间通信和同步。</p>
</li>
</ul>
<p>使用队列集时，你需要了解如何创建、添加和访问队列集，以及如何使用队列集<br>API 进行数据的发送和接收。队列集是 FreeRTOS<br>提供的一个强大工具，用于更灵活地组织和处理任务之间的数据流。</p>
<p>想象一下你有一个智能家居系统，有一个任务负责处理温度信息，另一个任务负责光照信息。你可能有两个队列，一个用于温度，一个用于光照。现在，通过队列集，你可以方便地管理这两个队列，让控制任务能够在需要时从这两个队列中获取信息，从而更智能地控制环境。</p>
<h2 id="队列集相关-API-函数介绍（熟悉）"><a href="#队列集相关-API-函数介绍（熟悉）" class="headerlink" title="队列集相关 API 函数介绍（熟悉）"></a>队列集相关 API 函数介绍（熟悉）</h2><p>队列集相关函数：</p>
<hr>
<p>函数 描述</p>
<hr>
<p>xQueueCreateSet() 创建队列集</p>
<p>xQueueAddToSet() 队列添加到队列集中</p>
<p>xQueueRemoveFromSet() 从队列集中移除队列</p>
<p>xQueueSelectFromSet() 获取队列集中有有效消息的队列</p>
<p>xQueueSelectFromSetFromISR() 在中断中获取队列集中有有效消息的队列</p>
<hr>
<h2 id="队列集操作实验（掌握）"><a href="#队列集操作实验（掌握）" class="headerlink" title="队列集操作实验（掌握）"></a>队列集操作实验（掌握）</h2><h3 id="实验目标-11"><a href="#实验目标-11" class="headerlink" title="实验目标"></a>实验目标</h3><p>学习使用 FreeRTOS 的队列集相关函数：</p>
<ul>
<li><p>start_task：用来创建其他 2 个任务，并创建队列集、队列&#x2F;信号量，将队列&#x2F;信号量添加到队列集中。</p>
</li>
<li><p>task1：用于扫描按键，当 KEY1 按下，往队列写入数据，当 KEY2 按下，释放二值信号量。</p>
</li>
<li><p>task2：读取队列集中的消息，并打印。</p>
</li>
</ul>
<h3 id="FreeRTOSConfig-h-代码清单-9"><a href="#FreeRTOSConfig-h-代码清单-9" class="headerlink" title="FreeRTOSConfig.h 代码清单"></a>FreeRTOSConfig.h 代码清单</h3><p>#define configUSE_QUEUE_SETS 1</p>
<h3 id="freertos-demo-c-代码清单-11"><a href="#freertos-demo-c-代码清单-11" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li>引入头文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include \&quot;queue.h\&quot;</span><br><span class="line"></span><br><span class="line">#include \&quot;semphr.h\&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>任务配置</p>
</li>
<li><p>入口函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">QueueSetHandle_t queueset_handle;</span><br><span class="line">QueueHandle_t queue_handle;</span><br><span class="line">QueueHandle_t semphr_handle;</span><br><span class="line">/**</span><br><span class="line"> * @description: FreeRTOS入口函数：创建任务函数并开始调度</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void FreeRTOS_Start(void)</span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreate((TaskFunction_t)Start_Task,</span><br><span class="line">                (char *)&quot;Start_Task&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE)START_TASK_STACK_DEPTH,</span><br><span class="line">                (void *)NULL,</span><br><span class="line">                (UBaseType_t)START_TASK_PRIORITY,</span><br><span class="line">                (TaskHandle_t *)&amp;start_task_handler);</span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>初始任务函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void Start_Task(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    taskENTER_CRITICAL(); /* 进入临界区 */</span><br><span class="line">    /* 创建队列集，可以存放2个队列 */</span><br><span class="line">    queueset_handle = xQueueCreateSet(2);</span><br><span class="line">    if (queueset_handle != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;队列集创建成功\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /* 创建队列 */</span><br><span class="line">    queue_handle = xQueueCreate(1, sizeof(uint8_t));</span><br><span class="line">    /* 创建二值信号量 */</span><br><span class="line">    semphr_handle = xSemaphoreCreateBinary();</span><br><span class="line">    /* 添加到队列集 */</span><br><span class="line">    xQueueAddToSet(queue_handle, queueset_handle);</span><br><span class="line">    xQueueAddToSet(semphr_handle, queueset_handle);</span><br><span class="line"></span><br><span class="line">    xTaskCreate((TaskFunction_t)Task1,</span><br><span class="line">                (char *)&quot;Task1&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE)TASK1_STACK_DEPTH,</span><br><span class="line">                (void *)NULL,</span><br><span class="line">                (UBaseType_t)TASK1_PRIORITY,</span><br><span class="line">                (TaskHandle_t *)&amp;task1_handler);</span><br><span class="line"></span><br><span class="line">    xTaskCreate((TaskFunction_t)Task2,</span><br><span class="line">                (char *)&quot;Task2&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE)TASK2_STACK_DEPTH,</span><br><span class="line">                (void *)NULL,</span><br><span class="line">                (UBaseType_t)TASK2_PRIORITY,</span><br><span class="line">                (TaskHandle_t *)&amp;task2_handler);</span><br><span class="line"></span><br><span class="line">    vTaskDelete(NULL);</span><br><span class="line">    taskEXIT_CRITICAL(); /* 退出临界区 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>task1 任务函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 实现队列发送以及信号量释放</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task1(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t key = 0;</span><br><span class="line">    BaseType_t err = 0;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        key = Key_Detect();</span><br><span class="line">        if (key == KEY1_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            err = xQueueSend(queue_handle, &amp;key, portMAX_DELAY);</span><br><span class="line">            if (err == pdPASS)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;往队列queue_handle写入数据成功\r\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (key == KEY2_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            err = xSemaphoreGive(semphr_handle);</span><br><span class="line">            if (err == pdPASS)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;释放信号量成功\r\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>task2 任务函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 获取队列集的消息</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task2(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    QueueSetMemberHandle_t member_handle;</span><br><span class="line">    uint8_t key;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        member_handle = xQueueSelectFromSet(queueset_handle, portMAX_DELAY);</span><br><span class="line">        if (member_handle == queue_handle)</span><br><span class="line">        &#123;</span><br><span class="line">            xQueueReceive(member_handle, &amp;key, portMAX_DELAY);</span><br><span class="line">            printf(&quot;获取到的队列数据=%d\r\n&quot;, key);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (member_handle == semphr_handle)</span><br><span class="line">        &#123;</span><br><span class="line">            xSemaphoreTake(member_handle, portMAX_DELAY);</span><br><span class="line">            printf(&quot;获取信号量成功\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="事件标志组"><a href="#事件标志组" class="headerlink" title="事件标志组"></a>事件标志组</h1><h2 id="事件标志组简介（了解）"><a href="#事件标志组简介（了解）" class="headerlink" title="事件标志组简介（了解）"></a>事件标志组简介（了解）</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>当在嵌入式系统中运行多个任务时，这些任务可能需要相互通信，协调其操作。FreeRTOS 中的事件标志组（Event<br>Flags Group）提供了一种轻量级的机制，用于在任务之间传递信息和同步操作。</p>
<p>事件标志组就像是一个共享的标志牌集合，每个标志位都代表一种特定的状态或事件。任务可以等待或设置这些标志位，从而实现任务之间的协同工作。</p>
<ol start="7">
<li>事件位（事件标志）</li>
</ol>
<p>事件位用于指示事件是否发生。<br>事件位通常称为事件标志。例如，应用程序可以：</p>
<ul>
<li><p>定义一个位（或标志）， 设置为 1 时表示”已收到消息并准备好处理”，<br>设置为 0 时表示”没有消息等待处理”。</p>
</li>
<li><p>定义一个位（或标志）， 设置为 1<br>时表示”应用程序已将准备发送到网络的消息排队”， 设置为 0 时表示<br>“没有消息需要排队准备发送到网络”。</p>
</li>
<li><p>定义一个位（或标志）， 设置为 1 时表示”需要向网络发送心跳消息”，<br>设置为 0 时表示”不需要向网络发送心跳消息”。</p>
<ol>
<li>事件组</li>
</ol>
</li>
</ul>
<p>事件组就是一组事件位。 事件组中的事件位通过位编号来引用。<br>同样，以上面列出的三个例子为例：</p>
<ul>
<li><p>事件标志组位编号为 0 表示”已收到消息并准备好处理”。</p>
</li>
<li><p>事件标志组位编号为 1 表示”应用程序已将准备发送到网络的消息排队”。</p>
</li>
<li><p>事件标志组位编号为 2 表示”需要向网络发送心跳消息”。</p>
</li>
</ul>
<h3 id="事件组和事件位数据类型"><a href="#事件组和事件位数据类型" class="headerlink" title="事件组和事件位数据类型"></a>事件组和事件位数据类型</h3><p>事件组由 EventGroupHandle_t 类型的变量引用。</p>
<p>在事件组中实现的位数（或标志数）取决于是使用 configUSE_16_BIT_TICKS 还是<br>configTICK_TYPE_WIDTH_IN_BITS 来控制 TickType_t 的类型：</p>
<ul>
<li><p>如果 configUSE_16_BIT_TICKS 设置为<br>1，则事件组内实现的位数（或标志数）为 8； 如果<br>configUSE_16_BIT_TICKS 设置为 0，则为 24。</p>
</li>
<li><p>如果 configTICK_TYPE_WIDTH_IN_BITS 设为<br>TICK_TYPE_WIDTH_16_BITS，则事件组内实现的位数（或标志数）为 8。</p>
</li>
<li><p>如果 configTICK_TYPE_WIDTH_IN_BITS 设为<br>TICK_TYPE_WIDTH_32_BITS，则为 24 。</p>
</li>
<li><p>如果 configTICK_TYPE_WIDTH_IN_BITS 设为<br>TICK_TYPE_WIDTH_64_BITS，则为 56。</p>
</li>
</ul>
<p>对 configUSE_16_BIT_TICKS 或 configTICK_TYPE_WIDTH_IN_BITS 的依赖源于 RTOS<br>任务内部实现中用于线程本地存储的数据类型。我们当前的版本不支持 configTICK_TYPE_WIDTH_IN_BITS 配置，只有 configUSE_16_BIT_TICKS 配置。</p>
<p>事件组中的所有事件位都 存储在 EventBits_t 类型的单个无符号整数变量中。<br>事件位 0 存储在位 0 中，事件位 1 存储在位 1 中，依此类推。</p>
<p>下图表示一个 24 位事件组，使用 3 个位来保存前面描述的 3 个示例事件。<br>在图片中，仅设置了事件位 2。</p>
<img src="/2025/08/04/RTOS/image7.png" class="" title="不同执行模式">

<h3 id="事件标志组和信号量的区别"><a href="#事件标志组和信号量的区别" class="headerlink" title="事件标志组和信号量的区别"></a>事件标志组和信号量的区别</h3><p>事件标志组（Event Flags<br>Group）和信号量（Semaphore）都是 FreeRTOS 中用于任务同步和通信的机制，但它们在用途和行为上有一些关键的区别。</p>
<hr>
<p>事件标志组 信号量</p>
<hr>
<p>主要用于任务之间的事件通知和同步。每个标志位通常代表一个特定的状态或事件，任务可以等待某些标志的发生或者设置标志来通知其他任务。 用于任务之间的资源控制和同步。信号量通常用来保护共享资源，控制对共享资源的访问，以及在任务之间提供同步。</p>
<p>每个标志位通常代表一个不同的事件，每个标志位只有两个状态，即已设置或未设置。 信号量是一个计数器，可以具有大于 1 的值，表示可用的资源数量。信号量的计数可以动态增减，而且可以用于实现互斥、同步等场景。</p>
<p>适用于需要向其他任务通知事件发生或等待特定事件的场景，例如数据准备就绪、某个条件满足等。 适用于需要对共享资源进行控制，限制同时访问某个资源的任务数量，以及确保任务按顺序访问共享资源的场景。</p>
<p>任务可以等待多个特定的标志位同时发生，或者等待任意一个标志位发生。 任务等待信号量的发放，当信号量的计数大于零时，任务可以继续执行。</p>
<hr>
<p>总体来说，事件标志组更侧重于任务间的事件通知和同步，而信号量更侧重于资源的控制和同步。在设计中，根据具体需求选择合适的机制会更有利于系统的设计和性能。</p>
<h2 id="事件标志组相关-API-函数介绍（熟悉）"><a href="#事件标志组相关-API-函数介绍（熟悉）" class="headerlink" title="事件标志组相关 API 函数介绍（熟悉）"></a>事件标志组相关 API 函数介绍（熟悉）</h2><p>事件标志组相关函数：</p>
<hr>
<p>函数 描述</p>
<hr>
<p>xEventGroupCreate() 使用动态方式创建事件标志组</p>
<p>xEventGroupCreateStatic() 使用静态方式创建事件标志组</p>
<p>xEventGroupClearBits() 清零事件标志位</p>
<p>xEventGroupClearBitsFromISR() 在中断中清零事件标志位</p>
<p>xEventGroupSetBits() 设置事件标志位</p>
<p>xEventGroupSetBitsFromISR() 在中断中设置事件标志位</p>
<p>xEventGroupWaitBits() 等待事件标志位</p>
<p>xEventGroupSync() 设置事件标志位，并等待事件标志位</p>
<hr>
<h2 id="事件标志组实验（掌握）"><a href="#事件标志组实验（掌握）" class="headerlink" title="事件标志组实验（掌握）"></a>事件标志组实验（掌握）</h2><h3 id="实验目标-12"><a href="#实验目标-12" class="headerlink" title="实验目标"></a>实验目标</h3><p>学习使用 FreeRTOS 的事件标志组相关函数：</p>
<ul>
<li><p>start_task：用来创建其他 2 个任务，并创建事件标志组。</p>
</li>
<li><p>task1：读取按键按下键值，根据不同键值将事件标志组相应事件位置一，模拟事件发生。</p>
</li>
<li><p>task2：同时等待事件标志组中的多个事件位，当这些事件位都置 1<br>的话就执行相应的处理。</p>
</li>
</ul>
<h3 id="freertos-demo-c-代码清单-12"><a href="#freertos-demo-c-代码清单-12" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li>引入头文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;event_groups.h&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>任务配置</p>
</li>
<li><p>入口函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">EventGroupHandle_t  eventgroup_handle;</span><br><span class="line">#define EVENTBIT_0  (1 &lt;&lt; 0)</span><br><span class="line">#define EVENTBIT_1  (1 &lt;&lt; 1)</span><br><span class="line">/**</span><br><span class="line"> * @description: FreeRTOS入口函数：创建任务函数并开始调度</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void FreeRTOS_Start(void)</span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreate((TaskFunction_t)Start_Task,</span><br><span class="line">                (char *)&quot;Start_Task&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE)START_TASK_STACK_DEPTH,</span><br><span class="line">                (void *)NULL,</span><br><span class="line">                (UBaseType_t)START_TASK_PRIORITY,</span><br><span class="line">                (TaskHandle_t *)&amp;start_task_handler);</span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>初始任务函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void Start_Task( void * pvParameters )</span><br><span class="line">&#123;</span><br><span class="line">    taskENTER_CRITICAL();               /* 进入临界区 */</span><br><span class="line">    /* 创建事件标志组 */</span><br><span class="line">    eventgroup_handle = xEventGroupCreate();</span><br><span class="line">    if(eventgroup_handle != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;事件标志组创建成功\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    xTaskCreate((TaskFunction_t         )   Task1,</span><br><span class="line">                (char *                 )   &quot;Task1&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE )   TASK1_STACK_DEPTH,</span><br><span class="line">                (void *                 )   NULL,</span><br><span class="line">                (UBaseType_t            )   TASK1_PRIORITY,</span><br><span class="line">                (TaskHandle_t *         )   &amp;task1_handler );</span><br><span class="line"></span><br><span class="line">    xTaskCreate((TaskFunction_t         )   Task2,</span><br><span class="line">                (char *                 )   &quot;Task2&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE )   TASK2_STACK_DEPTH,</span><br><span class="line">                (void *                 )   NULL,</span><br><span class="line">                (UBaseType_t            )   TASK2_PRIORITY,</span><br><span class="line">                (TaskHandle_t *         )   &amp;task2_handler );</span><br><span class="line">    vTaskDelete(NULL);</span><br><span class="line">    taskEXIT_CRITICAL();                /* 退出临界区 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>task1 任务函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 根据按键，事件标志组相应为置一</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task1(void * pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t key = 0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        key = Key_Detect();</span><br><span class="line">        if(key == KEY1_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            /* 将事件标志组的bit0位置1 */</span><br><span class="line">            xEventGroupSetBits( eventgroup_handle, EVENTBIT_0);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(key == KEY2_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            /* 将事件标志组的bit1位置1 */</span><br><span class="line">            xEventGroupSetBits( eventgroup_handle, EVENTBIT_1);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>task2 任务函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 同时等待事件标志组中的多个事件位</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task2(void * pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    EventBits_t event_bit = 0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        event_bit = xEventGroupWaitBits( eventgroup_handle,         /* 事件标志组句柄 */</span><br><span class="line">                                         EVENTBIT_0 | EVENTBIT_1,   /* 等待事件标志组的bit0和bit1位 */</span><br><span class="line">                                         pdTRUE,                    /* 成功等待到事件标志位后，清除事件标志组中的bit0和bit1位 */</span><br><span class="line">                                         pdTRUE,                    /* 等待事件标志组的bit0和bit1位都置1,就成立 */</span><br><span class="line">                                         portMAX_DELAY );           /* 一直等 */</span><br><span class="line">        printf(&quot;等待到的事件标志位值=%#x\r\n&quot;,event_bit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FreeRTOS-任务通知"><a href="#FreeRTOS-任务通知" class="headerlink" title="FreeRTOS 任务通知"></a>FreeRTOS 任务通知</h1><h2 id="任务通知的简介（了解）"><a href="#任务通知的简介（了解）" class="headerlink" title="任务通知的简介（了解）"></a>任务通知的简介（了解）</h2><p>任务通知是 FreeRTOS<br>中一种用于任务间通信的机制，它允许一个任务向其他任务发送简单的通知或信号，以实现任务间的同步和协作。任务通知通常用于替代二值信号量或事件标志组，提供了更轻量级的任务间通信方式。</p>
<p>大多数任务间通信方法通过中间对象，如队列、信号量或事件组。发送任务写入通信对象，接收任务从通信对象读取。当使用直接任务通知时，顾名思义，发送任务直接向接收任务发送通知，而无需中间对象。</p>
<p>每个 RTOS 任务都有一个任务通知组，每条通知均独立运行，都有”挂起”或”非挂起”的通知状态，以及一个 32 位通知值。常量 configTASK_NOTIFICATION_ARRAY_ENTRIES 可设置任务通知组中的索引数量。<br>在 FreeRTOS V10.4.0 版本前，任务只有单条任务通知（即只能一对一），没有任务通知组。</p>
<p>向任务发送”任务通知” 会将目标任务通知设为”挂起”状态。正如任务可以阻塞中间对象（如等待信号量可用的信号量），<br>任务也可以阻塞任务通知，以等待通知状态变为”挂起”。向任务发送”任务通知”也可以更新目标通知的值（可选），可使用下列任一方法：</p>
<ul>
<li><p>覆盖原值，无论接收任务是否已读取被覆盖的值。</p>
</li>
<li><p>覆盖原值（仅当接收任务已读取被覆盖的值时）。</p>
</li>
<li><p>在值中设置一个或多个位。</p>
</li>
<li><p>对值进行增量（添加 1）。</p>
</li>
</ul>
<p>RTOS 任务通知功能默认为启用状态，将 configUSE_TASK_NOTIFICATIONS<br>设为 0 可以禁用。</p>
<h2 id="任务通知相关-API-函数介绍（熟悉）"><a href="#任务通知相关-API-函数介绍（熟悉）" class="headerlink" title="任务通知相关 API 函数介绍（熟悉）"></a>任务通知相关 API 函数介绍（熟悉）</h2><p>任务通知相关函数如下：</p>
<hr>
<p>函数 描述</p>
<hr>
<p>xTaskNotify() 发送通知，带有通知值</p>
<p>xTaskNotifyAndQuery() 发送通知，带有通知值并且保留接收任务的原通知值</p>
<p>xTaskNotifyGive() 发送通知，不带通知值</p>
<p>xTaskNotifyFromISR() 在中断中发送任务通知</p>
<p>xTaskNotifyAndQueryFromISR()</p>
<p>vTaskNotifyGiveFromISR()</p>
<p>ulTaskNotifyTake() 获取任务通知，可选退出函数时对通知值清零或减 1</p>
<p>xTaskNotifyWait() 获取任务通知，可获取通知值和清除通知值的指定位</p>
<hr>
<p>注意：发送通知有相关 ISR 函数，接收通知没有 ISR 函数，不能在 ISR 中接收任务通知。</p>
<h2 id="任务通知模拟信号量实验（掌握）"><a href="#任务通知模拟信号量实验（掌握）" class="headerlink" title="任务通知模拟信号量实验（掌握）"></a>任务通知模拟信号量实验（掌握）</h2><h3 id="实验目标-13"><a href="#实验目标-13" class="headerlink" title="实验目标"></a>实验目标</h3><p>学习将任务通知用作轻量级二进制信号量：</p>
<ul>
<li><p>start_task：用来创建其他 2 个任务。</p>
</li>
<li><p>task1：用于按键扫描，当检测到按键 KEY1 被按下时，将发送任务通知。</p>
</li>
<li><p>task2：用于接收任务通知，并打印相关提示信息。</p>
</li>
</ul>
<h3 id="freertos-demo-c-代码清单-13"><a href="#freertos-demo-c-代码清单-13" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li><p>任务配置</p>
</li>
<li><p>入口函数</p>
</li>
<li><p>初始任务函数</p>
</li>
<li><p>task1 任务函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 发送任务通知值</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task1(void * pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t key = 0;</span><br><span class="line"></span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        key = Key_Detect();</span><br><span class="line">        if(key == KEY1_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;任务通知模拟二值信号量释放\r\n&quot;);</span><br><span class="line">            xTaskNotifyGive(task2_handler);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>task2 任务函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 接收任务通知值</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task2(void * pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t rev = 0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        rev = ulTaskNotifyTake(pdTRUE , portMAX_DELAY);</span><br><span class="line">        if(rev != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;接收任务通知成功，模拟获取二值信号量\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务通知模拟消息邮箱实验（掌握）"><a href="#任务通知模拟消息邮箱实验（掌握）" class="headerlink" title="任务通知模拟消息邮箱实验（掌握）"></a>任务通知模拟消息邮箱实验（掌握）</h2><h3 id="实验目标-14"><a href="#实验目标-14" class="headerlink" title="实验目标"></a>实验目标</h3><p>学习将任务通知用作轻量级邮箱：</p>
<ul>
<li><p>start_task：用来创建其他 2 个任务。</p>
</li>
<li><p>task1：用于按键扫描，将按下的按键键值通过任务通知发送给指定任务。</p>
</li>
<li><p>task2：用于接收任务通知，并根据接收到的数据做相应动作。</p>
</li>
</ul>
<h3 id="freertos-demo-c-代码清单-14"><a href="#freertos-demo-c-代码清单-14" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li><p>任务配置</p>
</li>
<li><p>入口函数</p>
</li>
<li><p>初始任务函数</p>
</li>
<li><p>task1 任务函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 发送任务通知值</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task1(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t key = 0;</span><br><span class="line"></span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        key = Key_Detect();</span><br><span class="line">        if ((key != 0) &amp;&amp; (task2_handler != NULL))</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;任务通知模拟消息邮箱发送，发送的键值为：%d\r\n&quot;, key);</span><br><span class="line">            xTaskNotify(task2_handler, key, eSetValueWithOverwrite);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>task2 任务函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 接收任务通知值</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task2(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t noyify_val = 0;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        xTaskNotifyWait(0, 0xFFFFFFFF, &amp;noyify_val, portMAX_DELAY);</span><br><span class="line">        switch (noyify_val)</span><br><span class="line">        &#123;</span><br><span class="line">        case KEY1_PRESS:</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;接收到的通知值为：%d\r\n&quot;, noyify_val);</span><br><span class="line">            LED_Toggle(LED1_Pin);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case KEY2_PRESS:</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;接收到的通知值为：%d\r\n&quot;, noyify_val);</span><br><span class="line">            LED_Toggle(LED2_Pin);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务通知模拟事件标志组实验（掌握）"><a href="#任务通知模拟事件标志组实验（掌握）" class="headerlink" title="任务通知模拟事件标志组实验（掌握）"></a>任务通知模拟事件标志组实验（掌握）</h2><h3 id="实验目标-15"><a href="#实验目标-15" class="headerlink" title="实验目标"></a>实验目标</h3><p>学习将任务通知用作轻量级事件标志组：</p>
<ul>
<li><p>start_task：用来创建其他 2 个任务。</p>
</li>
<li><p>task1：用于按键扫描，当检测到按键按下时，发送任务通知设置不同标志位。</p>
</li>
<li><p>task2：用于接收任务通知，并打印相关提示信息。</p>
</li>
</ul>
<h3 id="freertos-demo-c-代码清单-15"><a href="#freertos-demo-c-代码清单-15" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li><p>任务配置</p>
</li>
<li><p>入口函数</p>
</li>
<li><p>初始任务函数</p>
</li>
<li><p>task1 任务函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 发送任务通知值</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task1(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t key = 0;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        key = Key_Detect();</span><br><span class="line">        if (key == KEY1_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;将bit0位置1\r\n&quot;);</span><br><span class="line">            xTaskNotify(task2_handler, EVENTBIT_0, eSetBits);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (key == KEY2_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;将bit1位置1\r\n&quot;);</span><br><span class="line">            xTaskNotify(task2_handler, EVENTBIT_1, eSetBits);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>task2 任务函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 接收任务通知值</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task2(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t notify_val = 0,event_bit = 0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        xTaskNotifyWait( 0, 0xFFFFFFFF, &amp;notify_val, portMAX_DELAY );</span><br><span class="line">        if(notify_val &amp; EVENTBIT_0)</span><br><span class="line">        &#123;</span><br><span class="line">            event_bit |= EVENTBIT_0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(notify_val &amp; EVENTBIT_1)</span><br><span class="line">        &#123;</span><br><span class="line">            event_bit |= EVENTBIT_1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(event_bit == (EVENTBIT_0|EVENTBIT_1))</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;任务通知模拟事件标志组接收成功\r\n&quot;);</span><br><span class="line">            event_bit = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FreeRTOS-软件定时器"><a href="#FreeRTOS-软件定时器" class="headerlink" title="FreeRTOS 软件定时器"></a>FreeRTOS 软件定时器</h1><h2 id="软件定时器的简介（了解）"><a href="#软件定时器的简介（了解）" class="headerlink" title="软件定时器的简介（了解）"></a>软件定时器的简介（了解）</h2><p>FreeRTOS<br>中的软件定时器是一种轻量级的时间管理工具，用于在任务中创建和管理定时器。软件定时器是基于<br>FreeRTOS<br>内核提供的时间管理功能实现的，允许开发者创建、启动、停止、删除和管理定时器，从而实现在任务中对时间的灵活控制。</p>
<p>软件定时器与硬件定时器的主要区别如下：</p>
<hr>
<p>软件定时器 硬件定时器</p>
<hr>
<p>FreeRTOS 提供的功能来模拟定时器，依赖系统的任务调度器来进行计时和任务调度 由芯片或微控制器提供，独立于<br>CPU，可以在后台运行，不受任务调度器的影响</p>
<p>精度和分辨率可能受到任务调度的影响 具有更高的精度和分辨率</p>
<p>不需要额外的硬件资源，但可能会增加系统的负载 占用硬件资源，不会增加 CPU 的负载</p>
<hr>
<p>软件定时器能够让函数在未来的设定时间执行。由定时器执行的函数称为定时器的回调函数。从定时器启动到其回调函数执行之间的时间被称为定时器的周期。简而言之，当定时器的周期到期时，定时器的回调函数会被执行。</p>
<p>定时器回调函数在定时器服务任务的上下文中执行，在定时器回调函数中不能调用导致阻塞的 API 函数。</p>
<p>软件定时器服务任务是任务调度器中的一个特殊任务，专门用于管理和维护软件定时器的正常运行。如果 configUSE_TIMERS<br>设置为 1，在开启任务调度器的时候，会自动创建软件定时器服务的任务。它主要负责软件定时器超时的逻辑判断、调用超时软件定时器的超时回调函数、处理软件定时器命令队列。</p>
<h2 id="软件定时器的状态（熟悉）"><a href="#软件定时器的状态（熟悉）" class="headerlink" title="软件定时器的状态（熟悉）"></a>软件定时器的状态（熟悉）</h2><p>FreeRTOS 中的软件定时器有三种状态，分别是：</p>
<ul>
<li><p>未创建（Uncreated）：软件定时器被创建之前的状态。在这个状态下，定时器的数据结构已经被定义，但尚未通过<br>xTimerCreate() 函数创建。</p>
</li>
<li><p>已创建（Created）：软件定时器已被成功创建，但尚未启动。在这个状态下，可以对定时器进行配置，如设置定时器的周期、回调函数等，但定时器并未开始计时。</p>
</li>
<li><p>已运行（Running）：软件定时器已经被启动，正在运行中。在这个状态下，定时器会按照预定的周期定时触发超时事件，执行注册的回调函数。</p>
</li>
</ul>
<h2 id="单次定时器和周期定时器（熟悉）"><a href="#单次定时器和周期定时器（熟悉）" class="headerlink" title="单次定时器和周期定时器（熟悉）"></a>单次定时器和周期定时器（熟悉）</h2><p>在 FreeRTOS 中，软件定时器主要有两种类型：一次性定时器和周期性定时器。</p>
<ul>
<li><p>一次性定时器（One-shot Timer）：<br>这种定时器在触发一次超时后就会停止，不再执行。适用于只需在特定时间执行一次任务或动作的场景。</p>
</li>
<li><p>周期性定时器（Periodic Timer）：<br>这种定时器会在每个超时周期都触发一次，循环执行。适用于需要在固定的时间间隔内重复执行任务或动作的场景。</p>
</li>
</ul>
<h2 id="FreeRTOS-软件定时器相关-API-函数（熟悉）"><a href="#FreeRTOS-软件定时器相关-API-函数（熟悉）" class="headerlink" title="FreeRTOS 软件定时器相关 API 函数（熟悉）"></a>FreeRTOS 软件定时器相关 API 函数（熟悉）</h2><p>软件定时器相关函数如下：</p>
<hr>
<p>函数 描述</p>
<hr>
<p>xTimerCreate() 动态方式创建软件定时器</p>
<p>xTimerCreateStatic() 静态方式创建软件定时器</p>
<p>xTimerStart() 开启软件定时器定时</p>
<p>xTimerStartFromISR() 在中断中开启软件定时器定时</p>
<p>xTimerStop() 停止软件定时器定时</p>
<p>xTimerStopFromISR() 在中断中停止软件定时器定时</p>
<p>xTimerReset() 复位软件定时器定时</p>
<p>xTimerResetFromISR() 在中断中复位软件定时器定时</p>
<p>xTimerChangePeriod() 更改软件定时器的定时超时时间</p>
<p>xTimerChangePeriodFromISR() 在中断中更改定时超时时间</p>
<hr>
<h2 id="FreeRTOS-软件定时器实验（掌握）"><a href="#FreeRTOS-软件定时器实验（掌握）" class="headerlink" title="FreeRTOS 软件定时器实验（掌握）"></a>FreeRTOS 软件定时器实验（掌握）</h2><h3 id="实验目标-16"><a href="#实验目标-16" class="headerlink" title="实验目标"></a>实验目标</h3><p>学习使用 FreeRTOS 软件定时器的函数：</p>
<ul>
<li><p>start_task：用来创建 task1 任务，并创建一次性定时器和周期性定时器。</p>
</li>
<li><p>task1：用于按键扫描，并对软件定时器进行开启、停止操作。</p>
</li>
</ul>
<h3 id="FreeRTOSConfig-h-代码清单-10"><a href="#FreeRTOSConfig-h-代码清单-10" class="headerlink" title="FreeRTOSConfig.h 代码清单"></a>FreeRTOSConfig.h 代码清单</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 软件定时器相关定义 */</span><br><span class="line">#define configUSE_TIMERS 1                                          /* 1: 使能软件定时器, 默认: 0。使能后需指定下面3个 */</span><br><span class="line">#define configTIMER_TASK_PRIORITY (configMAX_PRIORITIES - 1)        /* 定义软件定时器任务的优先级 */</span><br><span class="line">#define configTIMER_QUEUE_LENGTH 5                                  /* 定义软件定时器命令队列的长度*/</span><br><span class="line">#define configTIMER_TASK_STACK_DEPTH (configMINIMAL_STACK_SIZE * 2) /* 定义软件定时器任务的栈空间大小*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="freertos-demo-c-代码清单-16"><a href="#freertos-demo-c-代码清单-16" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li>引入头文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;timers.h&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>任务配置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* 启动任务函数 */</span><br><span class="line">#define START_TASK_PRIORITY 1</span><br><span class="line">#define START_TASK_STACK_DEPTH 128</span><br><span class="line">TaskHandle_t start_task_handler;</span><br><span class="line">void Start_Task(void *pvParameters);</span><br><span class="line"></span><br><span class="line">/* Task1 任务 配置 */</span><br><span class="line">#define TASK1_PRIORITY 2</span><br><span class="line">#define TASK1_STACK_DEPTH 128</span><br><span class="line">TaskHandle_t task1_handler;</span><br><span class="line">void Task1(void *pvParameters);</span><br><span class="line"></span><br><span class="line">void timer1_callback( TimerHandle_t pxTimer );</span><br><span class="line">void timer2_callback( TimerHandle_t pxTimer );</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>入口函数</p>
</li>
<li><p>初始任务函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">TimerHandle_t timer1_handle = 0; /* 单次定时器 */</span><br><span class="line">TimerHandle_t timer2_handle = 0; /* 周期定时器 */</span><br><span class="line">void Start_Task(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    taskENTER_CRITICAL(); /* 进入临界区 */</span><br><span class="line">    /* 创建单次定时器 */</span><br><span class="line">    timer1_handle = xTimerCreate(&quot;timer1&quot;,</span><br><span class="line">                                 500,</span><br><span class="line">                                 pdFALSE,</span><br><span class="line">                                 (void *)1,</span><br><span class="line">                                 timer1_callback);</span><br><span class="line"></span><br><span class="line">    /* 创建周期定时器 */</span><br><span class="line">    timer2_handle = xTimerCreate(&quot;timer2&quot;,</span><br><span class="line">                                 2000,</span><br><span class="line">                                 pdTRUE,</span><br><span class="line">                                 (void *)2,</span><br><span class="line">                                 timer2_callback);</span><br><span class="line"></span><br><span class="line">    xTaskCreate((TaskFunction_t)Task1,</span><br><span class="line">                (char *)&quot;Task1&quot;,</span><br><span class="line">                (configSTACK_DEPTH_TYPE)TASK1_STACK_DEPTH,</span><br><span class="line">                (void *)NULL,</span><br><span class="line">                (UBaseType_t)TASK1_PRIORITY,</span><br><span class="line">                (TaskHandle_t *)&amp;task1_handler);</span><br><span class="line">    vTaskDelete(NULL);</span><br><span class="line">    taskEXIT_CRITICAL(); /* 退出临界区 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>task1 任务函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 根据按键控制软件定时器</span><br><span class="line"> * @param &#123;void *&#125; pvParameters</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Task1(void *pvParameters)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t key = 0;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        key = Key_Detect();</span><br><span class="line">        if (key == KEY1_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            xTimerStart(timer1_handle, portMAX_DELAY);</span><br><span class="line">            xTimerStart(timer2_handle, portMAX_DELAY);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (key == KEY2_PRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            xTimerStop(timer1_handle, portMAX_DELAY);</span><br><span class="line">            xTimerStop(timer2_handle, portMAX_DELAY);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>超时回调函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: timer1的超时回调函数</span><br><span class="line"> * @param &#123;TimerHandle_t&#125; pxTimer 定时器句柄</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void timer1_callback(TimerHandle_t pxTimer)</span><br><span class="line">&#123;</span><br><span class="line">    static uint32_t timer = 0;</span><br><span class="line">    printf(&quot;timer1的运行次数=%d\r\n&quot;, ++timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @description: timer2的超时回调函数</span><br><span class="line"> * @param &#123;TimerHandle_t&#125; pxTimer 定时器句柄</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void timer2_callback(TimerHandle_t pxTimer)</span><br><span class="line">&#123;</span><br><span class="line">    static uint32_t timer = 0;</span><br><span class="line">    printf(&quot;timer2的运行次数=%d\r\n&quot;, ++timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Tickless-低功耗模式"><a href="#Tickless-低功耗模式" class="headerlink" title="Tickless 低功耗模式"></a>Tickless 低功耗模式</h1><h2 id="低功耗模式简介（了解）"><a href="#低功耗模式简介（了解）" class="headerlink" title="低功耗模式简介（了解）"></a>低功耗模式简介（了解）</h2><p>FreeRTOS 的 Tickless<br>模式是一种特殊的运行模式，用于最小化系统的时钟中断频率，以降低功耗。在<br>Tickless<br>模式下，系统只在有需要时才会启动时钟中断，而在无任务要运行时则完全进入休眠状态，从而降低功耗。在滴答中断重启时，会对<br>RTOS 滴答计数值进行校正调整。</p>
<p>Tickless 模式的实现方式通常依赖于微控制器的硬件特性，尤其是低功耗定时器或实时时钟单元。以下是<br>Tickless 模式的一般工作原理：</p>
<ul>
<li><p>空闲任务检测：FreeRTOS 会通过空闲任务（Idle<br>Task）来检测系统是否有任务需要执行。如果没有任务需要执行，系统可以进入休眠状态。</p>
</li>
<li><p>时钟中断：当有任务需要执行时，系统会启动时钟中断，唤醒处理器。</p>
</li>
<li><p>时钟中断处理：在时钟中断处理函数中，FreeRTOS<br>将检查任务的状态并决定是否继续执行。</p>
</li>
<li><p>休眠状态：如果没有任务需要执行，系统可以进入休眠状态，关闭时钟中断。在休眠状态下，处理器可以进入更低功耗的模式。</p>
</li>
<li><p>任务唤醒：当有任务需要执行时，系统会再次启动时钟中断，唤醒处理器，然后执行相应的任务。</p>
</li>
</ul>
<p>在 Tickless<br>模式下，系统的时钟中断频率明显降低，从而降低了系统的平均功耗。Tickless<br>模式适用于那些对功耗要求较高、需要长时间运行在低功耗状态的嵌入式系统。比如：电池驱动设备、物联网（IoT）设备、低功耗传感器节点、无线通信模块等。</p>
<h2 id="Tickless-模式详解（熟悉）"><a href="#Tickless-模式详解（熟悉）" class="headerlink" title="Tickless 模式详解（熟悉）"></a>Tickless 模式详解（熟悉）</h2><p>STM32F103xC、STM32F103xD 和 STM32F103xE 增强型产品支持三种低功耗模式，可以在要求低功耗、短启动时间和多种唤醒事件之间达到最佳的平衡。</p>
<ol>
<li>睡眠模式（Sleep Mode）</li>
</ol>
<p>只有 CPU 停止，所有外设处于工作状态并可在发生中断&#x2F;事件时唤醒 CPU。</p>
<ol start="2">
<li>停机模式（Stop Mode）</li>
</ol>
<p>在保持 SRAM 和寄存器内容不丢失的情况下，停机模式可以达到最低的电能消耗。在停机模式下，停止所有内部 1.8V 部分的供电，PLL、HSI 的 RC 振荡器和 HSE 晶体振荡器被关闭，调压器可以被置于普通模式或低功耗模式。可以通过任一配置成 EXTI 的信号把微控制器从停机模式中唤醒，EXTI 信号可以是 16 个外部 I&#x2F;O<br>口之一、PVD 的输出、RTC 闹钟或 USB 的唤醒信号。</p>
<ol start="3">
<li>待机模式（Standby Mode）</li>
</ol>
<p>在待机模式下可以达到最低的电能消耗。内部的电压调压器被关闭，因此所有内部 1.8V 部分的供电被切断；PLL、HSI 的 RC 振荡器和 HSE 晶体振荡器也被关闭；进入待机模式后，SRAM 和寄存器的内容将消失，但后备寄存器的内容仍然保留，待机电路仍工作。从待机模式退出的条件是：NRST 上的外部复位信号、IWDG 复位、WKUP 引脚上的一个上升边<br>沿或 RTC 的闹钟到时。</p>
<p>注意：在进入停机或待机模式时，RTC、IWDG 和对应的时钟不会被停止。</p>
<img src="/2025/08/04/RTOS/image8.png" class="" title="不同执行模式">
<p>主要使用睡眠模式，任何中断或事件都可以唤醒睡眠模式。Tickless 低功耗模式通过调用指令<br>__WFI 实现睡眠模式</p>
<p>FreeRTOS 系统中的所有其它任务都不在运行时（处于阻塞或挂起），会运行空闲任务。所以想不影响系统运行又降低功耗，可以在空闲任务执行的期间，让 MCU<br>进入相应的低功耗模式。</p>
<p>由于滴答定时器频繁中断则会影响低功耗，所以 FreeRTOS 的 Tickless 低功耗模式会自动把滴答定时器的中断周期修改为低功耗运行时间，退出低功耗后再补上系统时钟节拍数。</p>
<h2 id="Tickless-模式相关配置项（掌握）"><a href="#Tickless-模式相关配置项（掌握）" class="headerlink" title="Tickless 模式相关配置项（掌握）"></a>Tickless 模式相关配置项（掌握）</h2><hr>
<p>配置项 说明</p>
<hr>
<p>configUSE_TICKLESS_IDLE 使能低功耗 Tickless 模式，默认 0</p>
<p>configEXPECTED_IDLE_TIME_BEFORE_SLEEP 系统进入相应低功耗模式的最短时长，默认 2</p>
<p>configPRE_SLEEP_PROCESSING(x) 在系统进入低功耗模式前执行的事务，比如关闭外设时钟</p>
<p>configPOST_SLEEP_PROCESSING(x) 系统退出低功耗模式后执行的事务，比如开启之前关闭的外设时钟</p>
<hr>
<h2 id="Tickless-低功耗模式实验（掌握）"><a href="#Tickless-低功耗模式实验（掌握）" class="headerlink" title="Tickless 低功耗模式实验（掌握）"></a>Tickless 低功耗模式实验（掌握）</h2><h3 id="实验目标-17"><a href="#实验目标-17" class="headerlink" title="实验目标"></a>实验目标</h3><p>学习使用 FreeRTOS 中的 Tickless 低功耗模式：</p>
<p>在 11.3 二值信号量实验案例中，加入低功耗模式，对比功耗结果，观察是否降低功耗。</p>
<h3 id="FreeRTOSConfig-h-代码清单-11"><a href="#FreeRTOSConfig-h-代码清单-11" class="headerlink" title="FreeRTOSConfig.h 代码清单"></a>FreeRTOSConfig.h 代码清单</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define configUSE_TICKLESS_IDLE 1</span><br><span class="line"></span><br><span class="line">#include &quot;freertos_demo.h&quot;</span><br><span class="line"></span><br><span class="line">#define configPRE_SLEEP_PROCESSING( x ) PRE_SLEEP_PROCESSING()</span><br><span class="line"></span><br><span class="line">#define configPOST_SLEEP_PROCESSING( x ) POST_SLEEP_PROCESSING()</span><br></pre></td></tr></table></figure>

<h3 id="freertos-demo-c-代码清单-17"><a href="#freertos-demo-c-代码清单-17" class="headerlink" title="freertos_demo.c 代码清单"></a>freertos_demo.c 代码清单</h3><ol>
<li><p>引入信号量头文件</p>
</li>
<li><p>低功耗处理函数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">* 进入低功耗前所需要执行的操作 */</span><br><span class="line">void PRE_SLEEP_PROCESSING(void)</span><br><span class="line">&#123;</span><br><span class="line">    __HAL_RCC_GPIOA_CLK_DISABLE();</span><br><span class="line">    __HAL_RCC_GPIOB_CLK_DISABLE();</span><br><span class="line">    __HAL_RCC_GPIOC_CLK_DISABLE();</span><br><span class="line">    __HAL_RCC_GPIOD_CLK_DISABLE();</span><br><span class="line">    __HAL_RCC_GPIOE_CLK_DISABLE();</span><br><span class="line">    __HAL_RCC_GPIOF_CLK_DISABLE();</span><br><span class="line">    __HAL_RCC_GPIOG_CLK_DISABLE();</span><br><span class="line">&#125;</span><br><span class="line">/* 退出低功耗后所需要执行的操作 */</span><br><span class="line">void POST_SLEEP_PROCESSING(void)</span><br><span class="line">&#123;</span><br><span class="line">    __HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line">    __HAL_RCC_GPIOB_CLK_ENABLE();</span><br><span class="line">    __HAL_RCC_GPIOC_CLK_ENABLE();</span><br><span class="line">    __HAL_RCC_GPIOD_CLK_ENABLE();</span><br><span class="line">    __HAL_RCC_GPIOE_CLK_ENABLE();</span><br><span class="line">    __HAL_RCC_GPIOF_CLK_ENABLE();</span><br><span class="line">    __HAL_RCC_GPIOG_CLK_ENABLE();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>任务配置</p>
</li>
<li><p>入口函数</p>
</li>
<li><p>初始任务函数</p>
</li>
<li><p>task1 任务函数</p>
</li>
<li><p>task2 任务函数</p>
</li>
</ol>
<h1 id="FreeRTOS-内存管理"><a href="#FreeRTOS-内存管理" class="headerlink" title="FreeRTOS 内存管理"></a>FreeRTOS 内存管理</h1><h2 id="FreeRTOS-内存管理简介（了解）"><a href="#FreeRTOS-内存管理简介（了解）" class="headerlink" title="FreeRTOS 内存管理简介（了解）"></a>FreeRTOS 内存管理简介（了解）</h2><p>在使用 FreeRTOS<br>创建任务、队列、信号量等对象时，通常都有动态创建和静态创建的方式。动态方式提供了更灵活的内存管理，而静态方式则更注重内存的静态分配和控制。</p>
<p>如果是动态创建的，那么标准 C 库 malloc() 和 free()<br>函数有时可用于此目的，但是有以下缺点：</p>
<ul>
<li><p>它们在嵌入式系统上并不总是可用。</p>
</li>
<li><p>它们占用了宝贵的代码空间。</p>
</li>
<li><p>它们不是线程安全的。</p>
</li>
<li><p>它们不是确定性的 （执行函数所需时间将因调用而异）。</p>
</li>
<li><p>...</p>
</li>
</ul>
<p>所以更多的时候需要的不是一个替代的内存分配实现。一个嵌入式&#x2F;实时系统的<br>RAM 和定时要求可能与另一个非常不同，所以单一的 RAM<br>分配算法将永远只适用于一个应用程序子集。为了避免此问题，FreeRTOS<br>将内存分配 API 保留在其可移植层，提供了五种内存管理算法：</p>
<ul>
<li><p>heap_1：最简单，不允许释放内存。</p>
</li>
<li><p>heap_2：允许释放内存，但不会合并相邻的空闲块。</p>
</li>
<li><p>heap_3：简单包装了标准 malloc() 和 free()，以保证线程安全。</p>
</li>
<li><p>heap_4：合并相邻的空闲块以避免碎片化。包含绝对地址放置选项。</p>
</li>
<li><p>heap_5：如同 heap_4，能够跨越多个不相邻内存区域的堆。</p>
</li>
</ul>
<h2 id="FreeRTOS-内存管理算法（熟悉）"><a href="#FreeRTOS-内存管理算法（熟悉）" class="headerlink" title="FreeRTOS 内存管理算法（熟悉）"></a>FreeRTOS 内存管理算法（熟悉）</h2><h3 id="heap-1-算法"><a href="#heap-1-算法" class="headerlink" title="heap_1 算法"></a>heap_1 算法</h3><p>heap_1<br>是最简单的实现方式。内存一经分配，它不允许内存再被释放。尽管如此，heap_1.c<br>还是适用于大量嵌入式应用程序。这是因为许多小型和深度嵌入的应用程序在系统启动时创建了所需的所有任务、队列、信号量等，并在程序的生命周期内使用所有这些对象（直到应用程序再次关闭或重新启动）。任何内容都不会被删除。</p>
<h3 id="heap-2-算法"><a href="#heap-2-算法" class="headerlink" title="heap_2 算法"></a>heap_2 算法</h3><p>heap_2 使用<strong>最佳</strong>适应算法，并且与方案 1<br>不同，它允许释放先前分配的块，它不将相邻的空闲块组合成一个大块。</p>
<p>heap_2.c 适用于许多必须动态创建对象的小型实时系统 。</p>
<ul>
<li><p>如果动态地创建和删除任务，且分配给正在创建任务的堆栈大小总是相同的，那么<br>heap2.c 可以在大多数情况下使用。</p>
</li>
<li><p>但是，如果分配给正在创建任务的堆栈的大小不是总相同，那么可用的空闲内存可能会被碎片化成许多小块，最终导致分配失败。</p>
</li>
</ul>
<p>heap_2<br>使用最佳适应算法，该算法在空闲内存中选择与请求的内存大小最接近的块来分配内存。下面是一个简单的例子来说明最佳适应算法：</p>
<p>假设有一个空闲内存，其中包含以下块：</p>
<ul>
<li><p>大小为 20 字节的空闲块。</p>
</li>
<li><p>大小为 15 字节的空闲块。</p>
</li>
<li><p>大小为 25 字节的空闲块。</p>
</li>
</ul>
<p>现在有一个任务请求分配 18 字节的内存。最佳适应算法将选择大小为 20<br>字节的块，因为它与请求的大小最接近。在选择这个块后，分配器可能会将该块分割为两部分，一部分大小为<br>18 字节，用于任务的内存，另一部分大小为 2 字节，留作未分配的块。</p>
<h3 id="heap-3-算法"><a href="#heap-3-算法" class="headerlink" title="heap_3 算法"></a>heap_3 算法</h3><p>heap_3 使用 C 库的 malloc 和 free<br>函数来进行内存分配和释放。它通过分配固定大小的块来管理内存，这些块的大小在配置<br>FreeRTOS 时进行定义，不会动态改变。</p>
<p>假设我们使用 Heap_3 管理内存，其中块的大小固定为 32<br>字节。初始时，整个内存被分割成大小为 32 字节的块：</p>
<ul>
<li><p>块 1（32 字节）。</p>
</li>
<li><p>块 2（32 字节）。</p>
</li>
<li><p>块 3（32 字节）。</p>
</li>
</ul>
<p>现在，有一个任务请求分配 20 字节的内存。Heap_3 算法将选择块<br>1，并将其分割成两部分：</p>
<ul>
<li><p>分配给任务的内存块（20 字节）。</p>
</li>
<li><p>剩余未分配的块（12 字节）。</p>
</li>
</ul>
<p>再假设另一个任务请求分配 40<br>字节的内存。由于没有足够大的块可供分配，heap_3 将返回分配失败的状态。</p>
<p>heap_3<br>的特点是块大小固定，这样可以简化内存管理。然而，也因为块大小不可变，可能导致内存碎片问题，即一些块可能无法完全被利用，从而浪费了一些内存。</p>
<h3 id="heap-4-算法"><a href="#heap-4-算法" class="headerlink" title="heap_4 算法"></a>heap_4 算法</h3><p>heap_4 使用第一适应算法，并且会将相邻的空闲内存块合并成大内存块，减少内存碎片。</p>
<p>第一适应算法会在可用内存块中选择第一个足够大的内存块进行分配。</p>
<p>假设有一个内存块链表，其中包含以下顺序的内存块：</p>
<ul>
<li><p>大小为 40 字节的块。</p>
</li>
<li><p>大小为 30 字节的块。</p>
</li>
<li><p>大小为 15 字节的块。</p>
</li>
<li><p>大小为 20 字节的块。</p>
</li>
</ul>
<p>如果一个任务需要申请 25 字节的内存，第一适应算法将选择大小为 40<br>字节的块，因为它是第一个足够大以容纳任务需求的内存块。（如果是 heap_2 的最佳适应算法，会选择 30 字节的块）</p>
<h3 id="heap-5-算法"><a href="#heap-5-算法" class="headerlink" title="heap_5 算法"></a>heap_5 算法</h3><p>heap_5 使用与 heap_4<br>相同的第一适应和内存合并算法，允许堆跨越多个不相邻（非连续）内存区域。适用于内存地址不连续的复杂场景。</p>
<h2 id="FreeRTOS-内存管理相关-API-函数介绍（熟悉）"><a href="#FreeRTOS-内存管理相关-API-函数介绍（熟悉）" class="headerlink" title="FreeRTOS 内存管理相关 API 函数介绍（熟悉）"></a>FreeRTOS 内存管理相关 API 函数介绍（熟悉）</h2><p>内存管理相关函数如下：</p>
<hr>
<p>函数 描述</p>
<hr>
<p>void * pvPortMalloc( size_t 申请内存<br>xWantedSize );</p>
<p>void vPortFree( void * pv ); 释放内存</p>
<p>size_t xPortGetFreeHeapSize( void 获取当前空闲内存的大小<br>);</p>
<hr>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8CRTOS%EF%BC%8C%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag"># 操作系统，RTOS，嵌入式</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/07/27/STM32F103C8T6%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="STM32F103C8T6微控制器入门学习笔记">
      <i class="fa fa-chevron-left"></i> STM32F103C8T6微控制器入门学习笔记
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">操作系统介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91"><span class="nav-number">1.1.</span> <span class="nav-text">什么是裸机开发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.2.</span> <span class="nav-text">什么是操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.2.1.</span> <span class="nav-text">通用操作系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.2.2.</span> <span class="nav-text">实时操作系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRTOS-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.3.</span> <span class="nav-text">FreeRTOS 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOS-%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="nav-number">1.3.1.</span> <span class="nav-text">FreeRTOS 发展历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOS-%E4%BC%98%E5%8A%BF"><span class="nav-number">1.3.2.</span> <span class="nav-text">FreeRTOS 优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOS-%E7%89%B9%E7%82%B9"><span class="nav-number">1.3.3.</span> <span class="nav-text">FreeRTOS 特点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FreeRTOS-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">2.</span> <span class="nav-text">FreeRTOS 基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">多任务处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="nav-number">2.2.</span> <span class="nav-text">任务调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="nav-number">2.3.</span> <span class="nav-text">任务状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRTOS-%E7%9A%84%E6%BB%B4%E7%AD%94"><span class="nav-number">2.4.</span> <span class="nav-text">FreeRTOS 的滴答</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">2.5.</span> <span class="nav-text">上下文切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1"><span class="nav-number">2.6.</span> <span class="nav-text">空闲任务</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FreeRTOS-%E7%A7%BB%E6%A4%8D"><span class="nav-number">3.</span> <span class="nav-text">FreeRTOS 移植</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRTOS-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.1.</span> <span class="nav-text">FreeRTOS 源码结构介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81"><span class="nav-number">3.1.1.</span> <span class="nav-text">获取源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.1.2.</span> <span class="nav-text">源码结构介绍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRTOS-%E5%9C%A8%E5%9F%BA%E4%BA%8E-HAL-%E5%BA%93%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%A7%BB%E6%A4%8D%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.2.</span> <span class="nav-text">FreeRTOS 在基于 HAL 库项目中移植步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E6%B7%BB%E5%8A%A0%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6"><span class="nav-number">3.2.1.</span> <span class="nav-text">目录添加源码文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E7%A8%8B%E6%B7%BB%E5%8A%A0%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6"><span class="nav-number">3.2.2.</span> <span class="nav-text">工程添加源码文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9"><span class="nav-number">3.2.3.</span> <span class="nav-text">系统配置文件修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9-stm32f1xx-it-c"><span class="nav-number">3.2.4.</span> <span class="nav-text">修改 stm32f1xx_it.c</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRTOS-%E5%9C%A8%E5%9F%BA%E4%BA%8E%E5%AF%84%E5%AD%98%E5%99%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%A7%BB%E6%A4%8D%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.3.</span> <span class="nav-text">FreeRTOS 在基于寄存器项目中移植步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E6%B7%BB%E5%8A%A0%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">目录添加源码文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E7%A8%8B%E6%B7%BB%E5%8A%A0%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6-1"><span class="nav-number">3.3.2.</span> <span class="nav-text">工程添加源码文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9-1"><span class="nav-number">3.3.3.</span> <span class="nav-text">系统配置文件修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main-c-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">3.3.4.</span> <span class="nav-text">main.c 中添加如下代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E"><span class="nav-number">3.4.</span> <span class="nav-text">系统配置文件说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRTOS-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.5.</span> <span class="nav-text">FreeRTOS 数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TickType-t"><span class="nav-number">3.5.1.</span> <span class="nav-text">TickType_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BaseType-t"><span class="nav-number">3.5.2.</span> <span class="nav-text">BaseType_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UBaseType-t"><span class="nav-number">3.5.3.</span> <span class="nav-text">UBaseType_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StackType-t"><span class="nav-number">3.5.4.</span> <span class="nav-text">StackType_t</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeROS-%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="nav-number">3.6.</span> <span class="nav-text">FreeROS 的命名规范</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">3.6.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">3.6.2.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F"><span class="nav-number">3.6.3.</span> <span class="nav-text">宏</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FreeRTOS-%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">4.</span> <span class="nav-text">FreeRTOS 的任务创建和删除</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E7%9A%84-API-%E5%87%BD%E6%95%B0%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">4.1.</span> <span class="nav-text">任务创建和删除的 API 函数（熟悉）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.1.</span> <span class="nav-text">动态创建任务函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.2.</span> <span class="nav-text">静态创建任务函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.3.</span> <span class="nav-text">任务删除函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E5%AE%9E%E9%AA%8C%EF%BC%88%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%89%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">任务创建和删除实验（动态方法）（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87"><span class="nav-number">4.2.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOSConfig-h-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95"><span class="nav-number">4.2.2.</span> <span class="nav-text">FreeRTOSConfig.h 代码清单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95"><span class="nav-number">4.2.3.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E5%AE%9E%E9%AA%8C%EF%BC%88%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%89%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">任务创建和删除实验（静态方法）（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87-1"><span class="nav-number">4.3.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOSConfig-h-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-1"><span class="nav-number">4.3.2.</span> <span class="nav-text">FreeRTOSConfig.h 代码清单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-1"><span class="nav-number">4.3.3.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FreeRTOS-%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%8C%82%E8%B5%B7%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="nav-number">5.</span> <span class="nav-text">FreeRTOS 的任务挂起与恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%8C%82%E8%B5%B7%E4%B8%8E%E6%81%A2%E5%A4%8D%E7%9A%84-API-%E5%87%BD%E6%95%B0%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">5.1.</span> <span class="nav-text">任务的挂起与恢复的 API 函数（熟悉）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0"><span class="nav-number">5.1.1.</span> <span class="nav-text">任务挂起函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%81%A2%E5%A4%8D%E5%87%BD%E6%95%B0"><span class="nav-number">5.1.2.</span> <span class="nav-text">任务恢复函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%81%A2%E5%A4%8D%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%AD%E6%96%AD%E4%B8%AD%E6%81%A2%E5%A4%8D%EF%BC%89"><span class="nav-number">5.1.3.</span> <span class="nav-text">任务恢复函数（中断中恢复）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%82%E8%B5%B7%E4%B8%8E%E6%81%A2%E5%A4%8D%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-number">5.1.4.</span> <span class="nav-text">挂起与恢复调度器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%8C%82%E8%B5%B7%E4%B8%8E%E6%81%A2%E5%A4%8D%E5%AE%9E%E9%AA%8C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">5.2.</span> <span class="nav-text">任务挂起与恢复实验（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87-2"><span class="nav-number">5.2.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOSConfig-h-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-2"><span class="nav-number">5.2.2.</span> <span class="nav-text">FreeRTOSConfig.h 代码清单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-2"><span class="nav-number">5.2.3.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FreeRTOS-%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86"><span class="nav-number">6.</span> <span class="nav-text">FreeRTOS 中断管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRTOS-%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">6.1.</span> <span class="nav-text">FreeRTOS 中断管理（熟悉）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOS-%E7%9A%84%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86"><span class="nav-number">6.1.1.</span> <span class="nav-text">FreeRTOS 的中断管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOS-%E7%9A%84%E5%BC%80%E5%85%B3%E4%B8%AD%E6%96%AD"><span class="nav-number">6.1.2.</span> <span class="nav-text">FreeRTOS 的开关中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOS-%E7%9A%84%E4%B8%B4%E7%95%8C%E6%AE%B5%E4%BB%A3%E7%A0%81"><span class="nav-number">6.1.3.</span> <span class="nav-text">FreeRTOS 的临界段代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%82%E8%B5%B7%E5%92%8C%E6%81%A2%E5%A4%8D%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-number">6.1.4.</span> <span class="nav-text">挂起和恢复任务调度器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRTOS-%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86%E5%AE%9E%E9%AA%8C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">6.2.</span> <span class="nav-text">FreeRTOS 中断管理实验（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87-3"><span class="nav-number">6.2.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">6.2.2.</span> <span class="nav-text">添加定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95"><span class="nav-number">6.2.3.</span> <span class="nav-text">main.c 代码清单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOSConfig-h-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-3"><span class="nav-number">6.2.4.</span> <span class="nav-text">FreeRTOSConfig.h 代码清单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-3"><span class="nav-number">6.2.5.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FreeRTOS-%E6%97%B6%E9%97%B4%E7%89%87%E8%B0%83%E5%BA%A6"><span class="nav-number">7.</span> <span class="nav-text">FreeRTOS 时间片调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%B0%83%E5%BA%A6%E7%AE%80%E4%BB%8B%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">7.1.</span> <span class="nav-text">时间片调度简介（熟悉）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%B0%83%E5%BA%A6%E5%AE%9E%E9%AA%8C%E6%BC%94%E7%A4%BA%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">7.2.</span> <span class="nav-text">时间片调度实验演示（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87-4"><span class="nav-number">7.2.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOSConfig-h-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-4"><span class="nav-number">7.2.2.</span> <span class="nav-text">FreeRTOSConfig.h 代码清单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-4"><span class="nav-number">7.2.3.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FreeRTOS-%E4%BB%BB%E5%8A%A1%E7%9B%B8%E5%85%B3-API-%E5%87%BD%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">FreeRTOS 任务相关 API 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRTOS-%E4%BB%BB%E5%8A%A1%E7%9B%B8%E5%85%B3-API-%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">8.1.</span> <span class="nav-text">FreeRTOS 任务相关 API 函数介绍（熟悉）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%9F%A5%E8%AF%A2-API-%E5%87%BD%E6%95%B0%E5%AE%9E%E9%AA%8C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">8.2.</span> <span class="nav-text">任务状态查询 API 函数实验（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87-5"><span class="nav-number">8.2.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOSConfig-h-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-5"><span class="nav-number">8.2.2.</span> <span class="nav-text">FreeRTOSConfig.h 代码清单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-5"><span class="nav-number">8.2.3.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%97%B6%E9%97%B4%E7%BB%9F%E8%AE%A1-API-%E5%87%BD%E6%95%B0%E5%AE%9E%E9%AA%8C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">8.3.</span> <span class="nav-text">任务时间统计 API 函数实验（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87-6"><span class="nav-number">8.3.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tim-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95"><span class="nav-number">8.3.2.</span> <span class="nav-text">tim.c 代码清单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-1"><span class="nav-number">8.3.3.</span> <span class="nav-text">main.c 代码清单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOSConfig-h-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-6"><span class="nav-number">8.3.4.</span> <span class="nav-text">FreeRTOSConfig.h 代码清单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-6"><span class="nav-number">8.3.5.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FreeRTOS-%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">FreeRTOS 时间管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">9.1.</span> <span class="nav-text">延时函数介绍（了解）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FreeRTOS-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">10.</span> <span class="nav-text">FreeRTOS 消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%AE%80%E4%BB%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">10.1.</span> <span class="nav-text">队列简介（了解）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3-API-%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">10.2.</span> <span class="nav-text">队列相关 API 函数介绍（熟悉）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97"><span class="nav-number">10.2.1.</span> <span class="nav-text">创建队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%80%E9%98%9F%E5%88%97%E5%86%99%E5%85%A5%E6%B6%88%E6%81%AF"><span class="nav-number">10.2.2.</span> <span class="nav-text">往队列写入消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E9%98%9F%E5%88%97%E8%AF%BB%E5%8F%96%E6%B6%88%E6%81%AF"><span class="nav-number">10.2.3.</span> <span class="nav-text">从队列读取消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C%E5%AE%9E%E9%AA%8C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">10.3.</span> <span class="nav-text">队列操作实验（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87-7"><span class="nav-number">10.3.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-7"><span class="nav-number">10.3.2.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">11.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E7%AE%80%E4%BB%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">11.1.</span> <span class="nav-text">信号量的简介（了解）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">11.2.</span> <span class="nav-text">二值信号量（熟悉）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E9%AA%8C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">11.3.</span> <span class="nav-text">二值信号量实验（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87-8"><span class="nav-number">11.3.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-8"><span class="nav-number">11.3.2.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">11.4.</span> <span class="nav-text">计数型信号量（熟悉）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E9%AA%8C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">11.5.</span> <span class="nav-text">计数型信号量实验（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87-9"><span class="nav-number">11.5.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOSConfig-h-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-7"><span class="nav-number">11.5.2.</span> <span class="nav-text">FreeRTOSConfig.h 代码清单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-9"><span class="nav-number">11.5.3.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E7%BF%BB%E8%BD%AC%E7%AE%80%E4%BB%8B%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">11.6.</span> <span class="nav-text">优先级翻转简介（熟悉）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">11.7.</span> <span class="nav-text">互斥信号量（熟悉）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E9%AA%8C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">11.8.</span> <span class="nav-text">互斥信号量实验（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87-10"><span class="nav-number">11.8.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOSConfig-h-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-8"><span class="nav-number">11.8.2.</span> <span class="nav-text">FreeRTOSConfig.h 代码清单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-10"><span class="nav-number">11.8.3.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E9%9B%86"><span class="nav-number">12.</span> <span class="nav-text">队列集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E9%9B%86%E7%AE%80%E4%BB%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">12.1.</span> <span class="nav-text">队列集简介（了解）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E9%9B%86%E7%9B%B8%E5%85%B3-API-%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">12.2.</span> <span class="nav-text">队列集相关 API 函数介绍（熟悉）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E9%9B%86%E6%93%8D%E4%BD%9C%E5%AE%9E%E9%AA%8C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">12.3.</span> <span class="nav-text">队列集操作实验（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87-11"><span class="nav-number">12.3.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOSConfig-h-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-9"><span class="nav-number">12.3.2.</span> <span class="nav-text">FreeRTOSConfig.h 代码清单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-11"><span class="nav-number">12.3.3.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84"><span class="nav-number">13.</span> <span class="nav-text">事件标志组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84%E7%AE%80%E4%BB%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">13.1.</span> <span class="nav-text">事件标志组简介（了解）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">13.1.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%84%E5%92%8C%E4%BA%8B%E4%BB%B6%E4%BD%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">13.1.2.</span> <span class="nav-text">事件组和事件位数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">13.1.3.</span> <span class="nav-text">事件标志组和信号量的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84%E7%9B%B8%E5%85%B3-API-%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">13.2.</span> <span class="nav-text">事件标志组相关 API 函数介绍（熟悉）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84%E5%AE%9E%E9%AA%8C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">13.3.</span> <span class="nav-text">事件标志组实验（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87-12"><span class="nav-number">13.3.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-12"><span class="nav-number">13.3.2.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FreeRTOS-%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5"><span class="nav-number">14.</span> <span class="nav-text">FreeRTOS 任务通知</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E7%9A%84%E7%AE%80%E4%BB%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">14.1.</span> <span class="nav-text">任务通知的简介（了解）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E7%9B%B8%E5%85%B3-API-%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">14.2.</span> <span class="nav-text">任务通知相关 API 函数介绍（熟悉）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E9%AA%8C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">14.3.</span> <span class="nav-text">任务通知模拟信号量实验（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87-13"><span class="nav-number">14.3.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-13"><span class="nav-number">14.3.2.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E6%A8%A1%E6%8B%9F%E6%B6%88%E6%81%AF%E9%82%AE%E7%AE%B1%E5%AE%9E%E9%AA%8C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">14.4.</span> <span class="nav-text">任务通知模拟消息邮箱实验（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87-14"><span class="nav-number">14.4.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-14"><span class="nav-number">14.4.2.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E6%A8%A1%E6%8B%9F%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84%E5%AE%9E%E9%AA%8C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">14.5.</span> <span class="nav-text">任务通知模拟事件标志组实验（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87-15"><span class="nav-number">14.5.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-15"><span class="nav-number">14.5.2.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FreeRTOS-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">15.</span> <span class="nav-text">FreeRTOS 软件定时器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E7%AE%80%E4%BB%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">15.1.</span> <span class="nav-text">软件定时器的简介（了解）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">15.2.</span> <span class="nav-text">软件定时器的状态（熟悉）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E6%AC%A1%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E5%91%A8%E6%9C%9F%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">15.3.</span> <span class="nav-text">单次定时器和周期定时器（熟悉）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRTOS-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3-API-%E5%87%BD%E6%95%B0%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">15.4.</span> <span class="nav-text">FreeRTOS 软件定时器相关 API 函数（熟悉）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRTOS-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">15.5.</span> <span class="nav-text">FreeRTOS 软件定时器实验（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87-16"><span class="nav-number">15.5.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOSConfig-h-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-10"><span class="nav-number">15.5.2.</span> <span class="nav-text">FreeRTOSConfig.h 代码清单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-16"><span class="nav-number">15.5.3.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Tickless-%E4%BD%8E%E5%8A%9F%E8%80%97%E6%A8%A1%E5%BC%8F"><span class="nav-number">16.</span> <span class="nav-text">Tickless 低功耗模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8E%E5%8A%9F%E8%80%97%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">16.1.</span> <span class="nav-text">低功耗模式简介（了解）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tickless-%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">16.2.</span> <span class="nav-text">Tickless 模式详解（熟悉）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tickless-%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E9%A1%B9%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">16.3.</span> <span class="nav-text">Tickless 模式相关配置项（掌握）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tickless-%E4%BD%8E%E5%8A%9F%E8%80%97%E6%A8%A1%E5%BC%8F%E5%AE%9E%E9%AA%8C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">16.4.</span> <span class="nav-text">Tickless 低功耗模式实验（掌握）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87-17"><span class="nav-number">16.4.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOSConfig-h-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-11"><span class="nav-number">16.4.2.</span> <span class="nav-text">FreeRTOSConfig.h 代码清单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-demo-c-%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95-17"><span class="nav-number">16.4.3.</span> <span class="nav-text">freertos_demo.c 代码清单</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FreeRTOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">17.</span> <span class="nav-text">FreeRTOS 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRTOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AE%80%E4%BB%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">17.1.</span> <span class="nav-text">FreeRTOS 内存管理简介（了解）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRTOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AE%97%E6%B3%95%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">17.2.</span> <span class="nav-text">FreeRTOS 内存管理算法（熟悉）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#heap-1-%E7%AE%97%E6%B3%95"><span class="nav-number">17.2.1.</span> <span class="nav-text">heap_1 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap-2-%E7%AE%97%E6%B3%95"><span class="nav-number">17.2.2.</span> <span class="nav-text">heap_2 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap-3-%E7%AE%97%E6%B3%95"><span class="nav-number">17.2.3.</span> <span class="nav-text">heap_3 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap-4-%E7%AE%97%E6%B3%95"><span class="nav-number">17.2.4.</span> <span class="nav-text">heap_4 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap-5-%E7%AE%97%E6%B3%95"><span class="nav-number">17.2.5.</span> <span class="nav-text">heap_5 算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRTOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3-API-%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="nav-number">17.3.</span> <span class="nav-text">FreeRTOS 内存管理相关 API 函数介绍（熟悉）</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CYZ"
      src="/images/chino2.jpg">
  <p class="site-author-name" itemprop="name">CYZ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/CYZ2024" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;CYZ2024" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/241180180@smail.nju.edu.cn" title="E-Mail → 241180180@smail.nju.edu.cn"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CYZ</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
