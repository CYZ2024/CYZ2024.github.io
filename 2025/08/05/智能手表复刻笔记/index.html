<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="整体框架硬件结构系统组成主控使用 STM32F411CEU6，操作系统使用 FreeRTOS，图形库使用的 LVGL。传感器部分：手势识别使用 6 轴 MPU6050；心率血氧使用的是 EM7028；海拔测量用的气压计 SPL06-001；电子指南针使用 LSM303DLHC；蓝牙芯片用的 KT6368A，有 SPP 功能，可以无线升级。">
<meta property="og:type" content="article">
<meta property="og:title" content="智能手表复刻笔记">
<meta property="og:url" content="http://example.com/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="CYZ的个人博客">
<meta property="og:description" content="整体框架硬件结构系统组成主控使用 STM32F411CEU6，操作系统使用 FreeRTOS，图形库使用的 LVGL。传感器部分：手势识别使用 6 轴 MPU6050；心率血氧使用的是 EM7028；海拔测量用的气压计 SPL06-001；电子指南针使用 LSM303DLHC；蓝牙芯片用的 KT6368A，有 SPP 功能，可以无线升级。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://no-chicken.com/images/OV-Watch/0/%E6%A1%86%E5%9B%BE.png">
<meta property="og:image" content="http://example.com/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/I2C.png">
<meta property="og:image" content="http://example.com/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/MPU6050.png">
<meta property="og:image" content="http://example.com/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/Pin.png">
<meta property="og:image" content="http://example.com/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/SPL06-001.png">
<meta property="og:image" content="http://example.com/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/compass.png">
<meta property="og:image" content="http://example.com/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/heartrate_pin.png">
<meta property="og:image" content="http://example.com/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/heart_rate.png">
<meta property="og:image" content="http://example.com/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/ble.png">
<meta property="og:image" content="http://example.com/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/KT6368A.png">
<meta property="og:image" content="https://no-chicken.com/images/OV-Watch/3/%E4%BE%9B%E7%94%B5.jpg">
<meta property="og:image" content="https://no-chicken.com/images/OV-Watch/3/Charge.jpg">
<meta property="og:image" content="https://no-chicken.com/images/OV-Watch/0/software%20structure.jpg">
<meta property="article:published_time" content="2025-08-05T03:31:43.000Z">
<meta property="article:modified_time" content="2025-08-11T14:30:54.000Z">
<meta property="article:author" content="CYZ">
<meta property="article:tag" content="复刻">
<meta property="article:tag" content="STM32">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://no-chicken.com/images/OV-Watch/0/%E6%A1%86%E5%9B%BE.png">

<link rel="canonical" href="http://example.com/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>智能手表复刻笔记 | CYZ的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CYZ的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/chino2.jpg">
      <meta itemprop="name" content="CYZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CYZ的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          智能手表复刻笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-08-05 11:31:43" itemprop="dateCreated datePublished" datetime="2025-08-05T11:31:43+08:00">2025-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-08-11 22:30:54" itemprop="dateModified" datetime="2025-08-11T22:30:54+08:00">2025-08-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">复刻笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h1><h2 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a>硬件结构</h2><h3 id="系统组成"><a href="#系统组成" class="headerlink" title="系统组成"></a>系统组成</h3><p>主控使用 STM32F411CEU6，操作系统使用 FreeRTOS，图形库使用的 LVGL。传感器部分：手势识别使用 6 轴 MPU6050；心率血氧使用的是 EM7028；海拔测量用的气压计 SPL06-001；电子指南针使用 LSM303DLHC；蓝牙芯片用的 KT6368A，有 SPP 功能，可以无线升级。</p>
<p><img src="https://no-chicken.com/images/OV-Watch/0/%E6%A1%86%E5%9B%BE.png"></p>
<span id="more"></span>

<p><em>处于复刻目的，以下讲详细解释每一个芯片引脚配置以及电路连接</em></p>
<h3 id="供电部分"><a href="#供电部分" class="headerlink" title="供电部分"></a>供电部分</h3><h3 id="充电部分"><a href="#充电部分" class="headerlink" title="充电部分"></a>充电部分</h3><h3 id="I2C-总线"><a href="#I2C-总线" class="headerlink" title="I2C 总线"></a>I2C 总线</h3><p>传感器统一放在背板，挂载在同一个 IIC 总线上</p>
<img src="/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/I2C.png" class="" title="I2C总线">

<h3 id="MPU-6050"><a href="#MPU-6050" class="headerlink" title="MPU-6050"></a>MPU-6050</h3><p>轴运动跟踪设备，集成 3 轴陀螺仪、3 轴加速度计及数字运动处理器（DMP），采用 4x4x0.9mm QFN 封装，支持 9 轴传感器融合。</p>


<img src="/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/MPU6050.png" class="" title="MPU6050">

<img src="/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/Pin.png" class="" title="各个引脚的简要说明">

<ul>
<li>引脚 12（INT）作为中断数字输出引脚，主要作用是通过输出信号向系统处理器触发中断，提示特定事件的发生，从而实现设备与处理器之间的高效通信，减少处理器的无效 polling（轮询），降低系统功耗。</li>
</ul>
<h3 id="SPL06-001-数字气压传感器"><a href="#SPL06-001-数字气压传感器" class="headerlink" title="SPL06-001 数字气压传感器"></a>SPL06-001 数字气压传感器</h3><p>SPL06-001，数字气压传感器，可同时测量压力和温度</p>
<img src="/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/SPL06-001.png" class="" title="SPL06-001典型用法">

<p>传感器地址为 0x77（默认），若 SDO 引脚下拉至地，则地址为 0x76 。此处下拉到地。</p>
<h3 id="AHT21B-温湿度传感器"><a href="#AHT21B-温湿度传感器" class="headerlink" title="AHT21B 温湿度传感器"></a>AHT21B 温湿度传感器</h3><p>一段话总结：SPL06-001 是歌尔股份生产的一款小型化数字气压传感器（版本 7.0，保密级别为机密），可同时测量压力和温度，具有无铅、无卤素、符合 RoHS 标准的特点 🔶1-4🔶。其压力测量范围为 300<del>1100hPa（对应海拔 + 9000m 至 - 500m），温度范围为 - 40</del>+85℃，压力相对精度达 ±0.06hPa，温度精度 ±0.5℃，支持 I2C 和 SPI 接口，具备 FIFO 功能（可存储 32 次测量），操作模式包括待机、命令和背景模式，适用于 GPS 导航增强、气象预报等场景。</p>
<p>电路简单，不用多看</p>
<h3 id="LSM303DLHC-指南针模块"><a href="#LSM303DLHC-指南针模块" class="headerlink" title="LSM303DLHC 指南针模块"></a>LSM303DLHC 指南针模块</h3><p>LSM303DLHC 是一款超紧凑型高性能 eCompass 模块，集成 3D 加速度计和 3D 磁力计，采用 LGA-14（3x5x1mm）封装。其核心特性包括：3 个磁场通道和 3 个加速度通道，加速度测量范围为 ±2g&#x2F;±4g&#x2F;±8g&#x2F;±16g，磁场测量范围为 ±1.3 至 ±8.1 高斯，支持 I2C 串行接口，模拟供电电压 2.16V 至 3.6V，具备低功耗模式、可编程中断、嵌入式温度传感器和 FIFO 等功能 1-10🔷1-11🔷1-12🔷1-14🔷1-15🔷。主要应用于倾斜补偿指南针、地图旋转、运动检测、计步器、虚拟现实设备等场景至 1-28🔷，工作温度范围为 - 40°C 至 + 85°C。</p>
<img src="/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/compass.png" class="" title="LSM303DLHC指南针模块典型用法">

<ul>
<li>INT1&#x2F;INT2：中断输出引脚，可配置为加速度计、磁力计的事件触发（如自由落体、磁场突变），触发后向主控发中断信号，实现 “事件 - 响应” 功能（如设备跌落保护）。</li>
<li>DRDY：数据就绪引脚，传感器完成一次数据采集（加速度 &#x2F; 磁场）后，该引脚电平变化，通知主控 “可读取新数据”，避免无效轮询。</li>
</ul>
<h3 id="EM7028-心率检测"><a href="#EM7028-心率检测" class="headerlink" title="EM7028 心率检测"></a>EM7028 心率检测</h3><p>EM7028 是一款具有 I2C 接口的低功耗心率传感器，内置 2 个 525nm 绿色 LED 和 LED 电流驱动器，支持连续模式（HRS1） 和脉冲模式（HRS2） 两种工作模式，适用于智能手表等心率检测场景。其核心特点包括 16 位 ADC、50Hz&#x2F;60Hz 闪烁噪声抑制、温度补偿、可编程 LED 电流（最高 200mA）及低平均功耗，工作电压范围为 2.5V~3.6V，封装尺寸为 4.0mm×2.4mm×1.35mm。</p>
<img src="/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/heartrate_pin.png" class="" title="EM7028引脚定义">
<img src="/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/heart_rate.png" class="" title="心跳检测电路">

<p><em>此处采用的是连续检测模式</em></p>
<h3 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h3><p>蓝牙模块由 BL1551B 单刀双掷（SPDT）模拟开关，KT6368A，24MHz 晶振</p>
<img src="/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/ble.png" class="" title="蓝牙电路">

<ul>
<li>BL1551B 的 ENB 为 1，A1 与 B 连接。<br>ENB 为 0，A2 与 B 连接</li>
<li>KT6368A 引脚定义如下图</li>
</ul>
<img src="/2025/08/05/%E6%99%BA%E8%83%BD%E6%89%8B%E8%A1%A8%E5%A4%8D%E5%88%BB%E7%AC%94%E8%AE%B0/KT6368A.png" class="" title="蓝牙电路">

<h3 id="STM32F411CEU6"><a href="#STM32F411CEU6" class="headerlink" title="STM32F411CEU6"></a>STM32F411CEU6</h3><p>先 mark，后面学</p>
<h3 id="供电部分-1"><a href="#供电部分-1" class="headerlink" title="供电部分"></a>供电部分</h3><p>供电部分使用了 TPS63020, 升降压芯片, 输入端接到电池, 使能端 TPS_EN 接到 MCU 的一个 GPIO(POWER_EN), 用于 MCU 控制使能, 软件控制供电. 同时 Bat 电池端接到开关, 即可以按键按下让供电芯片使能. 这个按键也复用为 KEY2, GPIO(WAKE)为高的时候代表按键按下.</p>
<p>也就是说, 关机后你可以按键 KEY2 上电，使能 TPS 供电芯片，然后过一段时间后，MCU 的 POWER_EN 引脚置 1，你松开 KEY2 后能够仍然保持 TPS 芯片使能供电。<br><img src="https://no-chicken.com/images/OV-Watch/3/%E4%BE%9B%E7%94%B5.jpg"></p>
<h3 id="充电部分-1"><a href="#充电部分-1" class="headerlink" title="充电部分"></a>充电部分</h3><p>充电部分使用 TP4056M, 用于给标准 3.7V 锂电池充电, 输入为 5V, 接口通过过孔连接到了 Back 的两个焊盘, 对应 2.84mm 磁吸线的两个触点, 一个+5V 一个 GND.<br>charge 连到 PA2，用于触发充电中断</p>
<p><img src="https://no-chicken.com/images/OV-Watch/3/Charge.jpg"></p>
<h3 id="EEPROM-和看门狗"><a href="#EEPROM-和看门狗" class="headerlink" title="EEPROM 和看门狗"></a>EEPROM 和看门狗</h3><p>分别用 BL24C02F-RRRC 和 TPS3823-33DBVR</p>
<h2 id="软件框架"><a href="#软件框架" class="headerlink" title="软件框架"></a>软件框架</h2><p>软件总体架构如下图<br><img src="https://no-chicken.com/images/OV-Watch/0/software%20structure.jpg"></p>
<h3 id="MDK-工程结构"><a href="#MDK-工程结构" class="headerlink" title="MDK 工程结构"></a>MDK 工程结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">├─Application/MDK-ARM               # 用于存放.s文件</span><br><span class="line">├─Application/User/Core             # 用于存放CubeMX生成的初始化文件</span><br><span class="line">│  │  main.c</span><br><span class="line">│  │  gpio.c</span><br><span class="line">│  │  ...</span><br><span class="line">│</span><br><span class="line">├─Application/User/System           # 用于存放自定义的delay.c sys.h等</span><br><span class="line">│  │  delay.c</span><br><span class="line">│  │  ...</span><br><span class="line">│</span><br><span class="line">├─Application/User/Tasks            # 用于存放任务线程的函数</span><br><span class="line">│  │  user_TaskInit.c</span><br><span class="line">│  │  user_HardwareInitTask.c</span><br><span class="line">│  │  user_RunModeTasks.c</span><br><span class="line">│  │  ...</span><br><span class="line">│</span><br><span class="line">├─Application/User/MidFunc          # 用于存放管理函数</span><br><span class="line">│  │  StrCalculate.c</span><br><span class="line">│  │  HWDataAccess.c</span><br><span class="line">│  │  PageManager.c</span><br><span class="line">│</span><br><span class="line">├─Application/User/GUI_APP          # 用于存放用户的ui app</span><br><span class="line">│  │  ui.c</span><br><span class="line">│  │  ...</span><br><span class="line">│</span><br><span class="line">├─Application/User/GUI_FONT_IMG     # 用于存放字体和图片</span><br><span class="line">│  │  ...</span><br><span class="line">│</span><br><span class="line">├─Drivers/CMSIS</span><br><span class="line">│  │  ...</span><br><span class="line">│</span><br><span class="line">├─Drivers/User/BSP                  # 用于存放板载设备驱动</span><br><span class="line">│  │  ...</span><br><span class="line">│</span><br><span class="line">├─Middleware/FreeRTOS               # FreeRTOS的底层</span><br><span class="line">│  │  ...</span><br><span class="line">│</span><br><span class="line">├─Middleware/LVGL/GUI               # LVGL的底层</span><br><span class="line">│  │  ...</span><br><span class="line">│</span><br><span class="line">└─Middleware/LVGL/GUI_Port          # 用于存放LVGL驱动</span><br><span class="line">    ├─lv_port_disp.c</span><br><span class="line">    ├─lv_port_indev.c</span><br></pre></td></tr></table></figure>

<h3 id="CubeMX-框架"><a href="#CubeMX-框架" class="headerlink" title="CubeMX 框架"></a>CubeMX 框架</h3><p>工程是用 CubeMX 生成的 MDK 工程，这里默认使用的 AC5 编译。</p>
<p>本次手表项目使用到的片上外设包括 GPIO, IIC, SPI, USART, TIM, ADC, DMA, 具体的对 PCB 板上器件的驱动，例如 LCD, EEPROM 等，详见 BSP。</p>
<p>简述一下各个片上外设的用途：</p>
<ol>
<li><p>DMA 这里主要是配合 SPI，SPI 通信不通过 CPU 而是通过 DMA 直接发送，如果使用多线程，那么视觉上来讲，刷屏应该就会快一些，因为 CPU 可以去执行其它任务；</p>
</li>
<li><p>IIC 主要用来跟 Back 板各个传感器进行通信，传感器都挂在一个总线上的；</p>
</li>
<li><p>TIM 主要是提供时基，另外一个就是给 LCD 调节背光；</p>
</li>
<li><p>ADC 只接了一个电池的分压，进行电池电压采样，预估剩余电量；</p>
</li>
<li><p>USART 接了蓝牙，方便进行 IAP 和与手机和电脑的助手通信。</p>
</li>
</ol>
<h3 id="板载驱动-BSP"><a href="#板载驱动-BSP" class="headerlink" title="板载驱动 BSP"></a>板载驱动 BSP</h3><ol>
<li><p>WDOG 采用外置的原因是，想要做睡眠低功耗，那么使用 MCU 内部的看门狗关闭不了，只能一直唤醒喂狗，否则就要重启，那么这样就失去了睡眠的意义了；</p>
</li>
<li><p>IIC 使用的软件模拟的方式进行驱动</p>
</li>
<li><p>key 按键的驱动，GPIO 设置有添加中断，这个是为了按键唤醒进入 STOP 模式的 MCU；</p>
</li>
<li><p>EM7028 心率，驱动中只写了对寄存器的读取，具体的心率算法和血氧算法没有放在 BSP 中；</p>
</li>
<li><p>DataSave 数据保存，为了方便保存手表设置等数据，自定义了 EEPROM 中的存储帧，详见代码；</p>
</li>
<li><p>IMU，dmp 库中的 init 函数是改过的，还有 MP6050.c，有比较多低功耗相关的，建议直接拿去用，不需要再改了。关于 MPU6050 记步的问题，难点主要在实现低功耗记步，它的内部是有一个寄存器存储步数的，应该 MPU6050 内部是有记步算法的，不需要用户在外部再自己设计记步算法了。</p>
</li>
</ol>
<h3 id="硬件访问机制-HWDataAccess"><a href="#硬件访问机制-HWDataAccess" class="headerlink" title="硬件访问机制-HWDataAccess"></a>硬件访问机制-HWDataAccess</h3><p>在 HWDataAccess.c 中，使用结构体进行各个硬件管理，如下代码所示。各个 typedef 定义在 HWDataAccess.h 中可以看到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/***************************</span><br><span class="line"> *  External Variables</span><br><span class="line"> ***************************/</span><br><span class="line">HW_InterfaceTypeDef HWInterface = &#123;</span><br><span class="line">    .RealTimeClock = &#123;</span><br><span class="line">        .GetTimeDate = HW_RTC_Get_TimeDate,</span><br><span class="line">        .SetDate = HW_RTC_Set_Date,</span><br><span class="line">        .SetTime = HW_RTC_Set_Time,</span><br><span class="line">        .CalculateWeekday = HW_weekday_calculate</span><br><span class="line">    &#125;,</span><br><span class="line">    .BLE = &#123;</span><br><span class="line">        .Enable = HW_BLE_Enable,</span><br><span class="line">        .Disable = HW_BLE_Disable</span><br><span class="line">    &#125;,</span><br><span class="line">    .Power = &#123;</span><br><span class="line">		.power_remain = 0,</span><br><span class="line">		.Init = HW_Power_Init,</span><br><span class="line">        .Shutdown = HW_Power_Shutdown,</span><br><span class="line">		.BatCalculate = HW_Power_BatCalculate</span><br><span class="line">    &#125;,</span><br><span class="line">    .LCD = &#123;</span><br><span class="line">        .SetLight = HW_LCD_Set_Light</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">	.IMU = &#123;</span><br><span class="line">		.ConnectionError = 1,</span><br><span class="line">		.Steps = 0,</span><br><span class="line">		.wrist_is_enabled = 0,</span><br><span class="line">		.wrist_state = WRIST_UP,</span><br><span class="line">		.Init = HW_MPU_Init,</span><br><span class="line">        .WristEnable = HW_MPU_Wrist_Enable,</span><br><span class="line">        .WristDisable = HW_MPU_Wrist_Disable,</span><br><span class="line">        .GetSteps = HW_MPU_Get_Steps,</span><br><span class="line">		.SetSteps = HW_MPU_Set_Steps</span><br><span class="line">    &#125;,</span><br><span class="line">	.AHT21 = &#123;</span><br><span class="line">		.ConnectionError = 1,</span><br><span class="line">		.humidity = 67,</span><br><span class="line">		.temperature = 26,</span><br><span class="line">		.Init = HW_AHT21_Init,</span><br><span class="line">		.GetHumiTemp = HW_AHT21_Get_Humi_Temp</span><br><span class="line">	&#125;,</span><br><span class="line">	.Barometer = &#123;</span><br><span class="line">		.ConnectionError = 1,</span><br><span class="line">		.altitude = 19,</span><br><span class="line">		.Init = HW_Barometer_Init,</span><br><span class="line">	&#125;,</span><br><span class="line">	.Ecompass = &#123;</span><br><span class="line">		.ConnectionError = 1,</span><br><span class="line">		.direction = 45,</span><br><span class="line">		.Init = HW_Ecompass_Init,</span><br><span class="line">		.Sleep = HW_Ecompass_Sleep</span><br><span class="line">	&#125;,</span><br><span class="line">	.HR_meter = &#123;</span><br><span class="line">		.ConnectionError = 1,</span><br><span class="line">		.HrRate = 0,</span><br><span class="line">		.SPO2 = 99,</span><br><span class="line">		.Init = HW_HRmeter_Init,</span><br><span class="line">		.Sleep = HW_HRmeter_Sleep</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如何在 UI 层使用 HWDataAccess 呢，例如在 HomePage 中的调节 LCD 亮度的回调函数中，这么使用，可以看到直接调用 HWInterface.LCD.SetLight(ui_LightSliderValue);即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void ui_event_LightSlider(lv_event_t * e)</span><br><span class="line">&#123;</span><br><span class="line">    lv_event_code_t event_code = lv_event_get_code(e);</span><br><span class="line">    lv_obj_t * target = lv_event_get_target(e);</span><br><span class="line">    if(event_code == LV_EVENT_VALUE_CHANGED)</span><br><span class="line">    &#123;</span><br><span class="line">        ui_LightSliderValue = lv_slider_get_value(ui_LightSlider);</span><br><span class="line">        HWInterface.LCD.SetLight(ui_LightSliderValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么他是如何在有硬件的 MDK 工程中也能用，LVGL 无硬件的仿真也能用，我们看到 HWInterface.LCD.SetLight 对应的函数是什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HW_InterfaceTypeDef HWInterface = &#123;</span><br><span class="line">    // 省略前面</span><br><span class="line">    .LCD = &#123;</span><br><span class="line">            .SetLight = HW_LCD_Set_Light</span><br><span class="line">        &#125;,</span><br><span class="line">    // 省略后面</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看到<code>HWInterface.LCD.SetLight</code>定义的是函数<code>HW_LCD_Set_Light</code>，而这个函数的内容如下，即当<code>HW_USE_LCD</code>使能时，运行这个函数，能够正常调光，当 LVGL 仿真中不使能硬件<code>HW_USE_HARDWARE</code>时, <code>HW_USE_LCD</code>也不使能，则此函数执行空，工程也不会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void HW_LCD_Set_Light(uint8_t dc)</span><br><span class="line">&#123;</span><br><span class="line">	#if HW_USE_LCD</span><br><span class="line">		LCD_Set_Light(dc);</span><br><span class="line">	#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LVGL-页面管理-PageManager"><a href="#LVGL-页面管理-PageManager" class="headerlink" title="LVGL 页面管理-PageManager"></a>LVGL 页面管理-PageManager</h3><p><strong>PageManager 框架</strong><br>OV-Watch 手表项目的 LVGL 页面有很多，在 GUI_App 文件夹中，Screen 文件夹中存放着所有的 page。由于 screen 很多，所以有必要进行页面管理。这里开一个栈进行页面管理。</p>
<p>首先看到<code>PageManager.h</code>, <code>Page_t</code>结构体是用于描述一个 LVGL 页面的，里面的对象有初始化函数<code>init</code>，反初始化函数<code>deinit</code>以及一个用于存放 lvgl 对象的地址的<code>lv_obj_t **page_obj</code>。</p>
<p><code>PageStack_t</code>结构体描述一个界面栈，用于存放<code>Page_t</code>页面结构体，<code>top</code>表示栈顶。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 页面栈深度</span><br><span class="line">#define MAX_DEPTH 6</span><br><span class="line"></span><br><span class="line">// 页面结构体</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    void (*init)(void);</span><br><span class="line">    void (*deinit)(void);</span><br><span class="line">    lv_obj_t **page_obj;</span><br><span class="line">&#125; Page_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 页面堆栈结构体</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    Page_t* pages[MAX_DEPTH];</span><br><span class="line">    uint8_t top;</span><br><span class="line">&#125; PageStack_t;</span><br><span class="line"></span><br><span class="line">extern PageStack_t PageStack;</span><br></pre></td></tr></table></figure>

<p>再看到<code>PageManager.c</code>，栈的初始化还有 push 和 pop 操作就不再赘述了，在 pop 函数中，除了将 top 减 1，还调用了页面 deinit 函数，负责反初始化当前页面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack-&gt;pages[--stack-&gt;top]-&gt;deinit();</span><br></pre></td></tr></table></figure>

<p><code>Page_Back()</code>, <code>Page_Back_Bottom()</code>, <code>Page_Load()</code>就是主要在代码中调用的函数了，分别的作用是 Back 到上一个界面，Back 到最底部的 Home 界面，以及 load 新的界面。</p>
<p><strong>如何在 ui app 中使用 PageManager</strong><br>这里以代码比较少的<code>ui_ChargPage.c</code>为例。<br>首先我们需要注册一个 Page 结构体存储当前的页面，填充好初始化<code>init</code>，反初始化函数<code>deinit</code>以及 LVGL 页面对象<code>&amp;ui_ChargPage</code>，然后我的<code>deinit</code>是用于删除定时器<code>timer</code>的，这里的<code>timer</code>主要用于刷当前页面的数据，所以不在当前页面时需要删除掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 省略前面...</span><br><span class="line"></span><br><span class="line">///////////////////// Page Manager //////////////////</span><br><span class="line">Page_t Page_Charg = &#123;ui_ChargPage_screen_init, ui_ChargPage_screen_deinit, &amp;ui_ChargPage&#125;;</span><br><span class="line"></span><br><span class="line">/////////////////////// Timer //////////////////////</span><br><span class="line">// need to be destroyed when the page is destroyed</span><br><span class="line">static void ChargPage_timer_cb(lv_timer_t * timer)</span><br><span class="line">&#123;</span><br><span class="line">    if(Page_Get_NowPage()-&gt;page_obj == &amp;ui_ChargPage)</span><br><span class="line">    &#123;</span><br><span class="line">        // 刷新数据等操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///////////////////// SCREEN init ////////////////////</span><br><span class="line">void ui_ChargPage_screen_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 省略中间...</span><br><span class="line">    // private timer</span><br><span class="line">    ui_ChargPageTimer = lv_timer_create(ChargPage_timer_cb, 2000,  NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/////////////////// SCREEN deinit ////////////////////</span><br><span class="line">void ui_ChargPage_screen_deinit(void)</span><br><span class="line">&#123;</span><br><span class="line">  lv_timer_del(ui_ChargPageTimer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 省略后面...</span><br></pre></td></tr></table></figure>

<h3 id="多线程任务"><a href="#多线程任务" class="headerlink" title="多线程任务"></a>多线程任务</h3><p>此项目都用的 CMSIS_OS_V2 的 API。Tasks 文件以及其作用如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├─Application/User/Tasks            # 用于存放任务线程的函数</span><br><span class="line">│  ├─user_TaskInit.c                # 初始化任务</span><br><span class="line">│  ├─user_HardwareInitTask.c        # 硬件初始化任务</span><br><span class="line">│  ├─user_RunModeTasks.c            # 运行模式任务</span><br><span class="line">│  ├─user_KeyTask.c                 # 按键任务</span><br><span class="line">│  ├─user_DataSaveTask.c            # 数据保存任务</span><br><span class="line">│  ├─user_MessageSendTask.c         # 消息发送任务</span><br><span class="line">│  ├─user_ChargeCheckTask.c         # 充电检查任务</span><br><span class="line">│  ├─user_SensUpdateTask.c          # 传感器更新任务</span><br><span class="line">│  ├─user_ScrRenewTask.c            # 屏幕刷新任务</span><br></pre></td></tr></table></figure>

<ol>
<li><p>任务初始化<code>TaskInit.c</code>，注册各个任务，分配空间，注册一些信号量，任务的汇总可以看这个文件。同时也创建了一个软件定时器，用于记录空闲时间，即用户没有操作过长就会发出<code>idle</code>信号，<code>idle</code>过长，就会发出<code>STOP</code>信号，进入睡眠。LVGL 的时钟提供也放在这个文件夹，为<code>LvHandlerTask</code>。看门狗的喂狗 Task 也放在这个文件中。</p>
</li>
<li><p>硬件初始化<code>user_HardwareInitTask.c</code>，其实这里应该叫 BootTask，不仅仅有硬件的初始化，最后还有 LVGL 的初始化。这个任务运行完后，会把本任务删除，即调用<code>vTaskDelete(NULL)</code>；</p>
</li>
<li><p>按键任务<code>keytask</code>，按键发生即发出信号量，调<code>osMessageQueuePut(Key_MessageQueue, &amp;keystr, 0, 1);</code>和<code>osMessageQueuePut(IdleBreak_MessageQueue, &amp;IdleBreakstr, 0, 1);</code>，一个是按键信号量，一个是空闲打断信号量；</p>
</li>
<li><p>屏幕切换任务<code>user_ScrRenewTask.c</code>，接受按键信号量，然后调用<code>PageManager</code>中的函数；</p>
</li>
<li><p>运行模式切换任务<code>user_RunModeTasks.c</code> ，主要用于进入 STOP 模式和退出 STOP 模式，接收到<code>Idle</code>超时发出的<code>Stop_MessageQueue</code>信号量就进入 STOP 模式。这里跟硬件和 UI 的睡眠时间设置强相关，比较耦合.</p>
</li>
<li><p>其它详见代码。</p>
</li>
</ol>
<h1 id="UI-与页面管理-LVGL-PageManager"><a href="#UI-与页面管理-LVGL-PageManager" class="headerlink" title="UI 与页面管理 (LVGL &amp; PageManager)"></a>UI 与页面管理 (LVGL &amp; PageManager)</h1><h1 id="多线程任务-FreeRTOS-Tasks"><a href="#多线程任务-FreeRTOS-Tasks" class="headerlink" title="多线程任务 (FreeRTOS Tasks)"></a>多线程任务 (FreeRTOS Tasks)</h1><h2 id="user-Taskslnit"><a href="#user-Taskslnit" class="headerlink" title="user_Taskslnit"></a>user_Taskslnit</h2><p>这个文件是整个 FreeRTOS 系统的“心脏”，它负责：</p>
<ol>
<li><p>定义所有任务的属性（名称、堆栈大小、优先级）。</p>
</li>
<li><p>创建所有任务的句柄（Handle）。</p>
</li>
<li><p>创建任务间通信用的消息队列（Message Queue）。</p>
</li>
<li><p>创建一个周期性软件定时器（Timer）。</p>
</li>
<li><p>提供一个总的初始化函数 User_Tasks_Init()，用于创建上述所有 RTOS 对象。</p>
</li>
<li><p>提供一些特殊用途的函数，如 LvHandlerTask（LVGL 图形库处理器）、WDOGFeedTask（看门狗喂狗任务）和 TaskTickHook（系统节拍钩子函数）。</p>
</li>
</ol>
<h3 id="任务句柄定义"><a href="#任务句柄定义" class="headerlink" title="任务句柄定义"></a>任务句柄定义</h3><ul>
<li>HardwaresInitTask，优先级 High+3</li>
<li>WDOGFeedTask，优先级 High+2</li>
<li>StopEnterTask，优先级 High+1</li>
<li>IdleEnterTask，优先级 High</li>
<li>KeyTask，优先级 Normal</li>
<li>MPUCheckTask，Low+2</li>
<li>DataSaveTask，优先级 Low+2</li>
<li>ScrRenewTask，优先级 Low+1</li>
<li>HRDataTask，优先级 Low+1</li>
<li>ChargPageEnterTask，优先级 Low+1</li>
<li>MessageSendTask，优先级 Low+1</li>
<li>LVGLHandlerTask，优先级 Low</li>
</ul>
<p>高优先级: HardwareInitTask, WDOGFeedTask, StopEnterTask 等，这些是保证系统启动、不死机和正确进入低功耗的关键任务，必须优先执行。</p>
<p>中等优先级: KeyTask 等，需要较快的响应速度。</p>
<p>低优先级: LvHandlerTask, SensorDataTask 等，这些是常规的数据处理和 UI 刷新任务，可以在 CPU 空闲时执行。</p>
<h3 id="消息队列定义"><a href="#消息队列定义" class="headerlink" title="消息队列定义"></a>消息队列定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Message queues ------------------------------------------------------------*/</span><br><span class="line">osMessageQueueId_t Key_MessageQueue;</span><br><span class="line">osMessageQueueId_t Idle_MessageQueue;</span><br><span class="line">osMessageQueueId_t Stop_MessageQueue;</span><br><span class="line">osMessageQueueId_t IdleBreak_MessageQueue;</span><br><span class="line">osMessageQueueId_t HomeUpdata_MessageQueue;</span><br><span class="line">osMessageQueueId_t DataSave_MessageQueue;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>Key_MessageQueue</code>: 用于从按键任务发送按键值。</p>
</li>
<li><p><code>Idle_MessageQueue</code>: 用于通知系统进入“空闲”状态（比如屏幕变暗）。</p>
</li>
<li><p><code>Stop_MessageQueue</code>: 用于通知系统进入“停止”（STOP）低功耗模式。</p>
</li>
<li><p><code>IdleBreak_MessageQueue</code>: 用于打断“空闲”或“停止”状态，让系统恢复正常。</p>
</li>
<li><p><code>HomeUpdata_MessageQueue</code>:&#96; 用于通知主界面更新显示数据。</p>
</li>
<li><p><code>DataSave_MessageQueue</code>: 用于触发数据保存任务。</p>
</li>
</ul>
<h3 id="User-Tasks-Init-总初始化函数"><a href="#User-Tasks-Init-总初始化函数" class="headerlink" title="User_Tasks_Init() - 总初始化函数"></a><code>User_Tasks_Init()</code> - 总初始化函数</h3><ul>
<li><p>这个函数在系统启动时（通常在 main()函数中）被调用，完成所有 RTOS 对象的创建。</p>
</li>
<li><p>创建并启动定时器:</p>
<p><code>osTimerNew(IdleTimerCallback, osTimerPeriodic, NULL, NULL)</code>: 创建一个新的定时器。</p>
<p><code>IdleTimerCallback</code>: 定时器到期时要调用的回调函数。</p>
<p><code>osTimerPeriodic</code>: 定时器是周期性的。</p>
<p><code>osTimerStart(IdleTimerHandle, 100)</code>: 启动这个定时器，周期为 100 毫秒。</p>
</li>
<li><p>创建消息队列:</p>
<p><code>osMessageQueueNew(1, 1, NULL)</code>: 创建一个新的消息队列。</p>
<p>第一个<code>1</code>: 队列能容纳的最大消息数量。</p>
<p>第二个<code>1</code>: 每个消息的大小（单位：字节）。</p>
</li>
<li><p>创建任务（线程）:</p>
<p><code>osThreadNew(HardwareInitTask, NULL, &amp;HardwareInitTask_attributes)</code>: 创建一个新的任务。</p>
<p><code>HardwareInitTask</code>: 任务的执行函数（任务的 C 函数名）。</p>
<p><code>NULL</code>: 传递给任务函数的参数（这里没有）。</p>
<p><code>&amp;HardwareInitTask_attributes</code>: 之前定义的任务属性结构体。</p>
</li>
<li><p>发送初始消息:</p>
<p><code>osMessageQueuePut(HomeUpdata_MessageQueue, &amp;HomeUpdataStr, 0, 1)</code>: 在所有任务创建后，立即向<code>HomeUpdata_MessageQueue</code>发送一个消息，目的是让手表一开机就主动更新一次主界面的数据。</p>
</li>
</ul>
<h3 id="TaskTickHook-系统节拍钩子函数"><a href="#TaskTickHook-系统节拍钩子函数" class="headerlink" title="TaskTickHook() - 系统节拍钩子函数"></a><code>TaskTickHook()</code> - 系统节拍钩子函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void TaskTickHook(void)</span><br><span class="line">&#123;</span><br><span class="line">	//to increase the LVGL tick</span><br><span class="line">	lv_tick_inc(1);</span><br><span class="line">	//to increase the timerpage&#x27;s timer...</span><br><span class="line">	if(ui_TimerPageFlag)</span><br><span class="line">	&#123;</span><br><span class="line">        // ... (秒表页面的计时逻辑) ...</span><br><span class="line">	&#125;</span><br><span class="line">	user_HR_timecount+=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Hook（钩子）函数是 RTOS 提供的一种机制，允许用户在内核的特定事件发生时执行自己的代码。</p>
</li>
<li><p><code>TaskTickHook</code>会在每个系统节拍（SysTick 中断）发生时被调用。在这个项目中，系统节拍周期是 1 毫秒。</p>
</li>
<li><p><code>lv_tick_inc(1);</code>: 告诉 LVGL 图形库时间过去了 1 毫秒。LVGL 内部的动画、淡入淡出等效果都依赖这个时间基准。这是将 LVGL 与 FreeRTOS 结合的关键一步。</p>
</li>
<li><p>秒表页面计时: <code>if(ui_TimerPageFlag)</code>判断当前是否在秒表页面，如果是，就执行计时逻辑。把计时放在这里可以保证其精度。</p>
</li>
<li><p><code>user_HR_timecount+=1;</code>: 一个全局的心率算法计时器，每毫秒加一。</p>
</li>
</ul>
<h3 id="LvHandlerTask-和-WDOGFeedTask"><a href="#LvHandlerTask-和-WDOGFeedTask" class="headerlink" title="LvHandlerTask() 和 WDOGFeedTask()"></a><code>LvHandlerTask()</code> 和 <code>WDOGFeedTask()</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void LvHandlerTask(void *argument)</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        // ...</span><br><span class="line">		lv_task_handler();</span><br><span class="line">        osDelay(1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WDOGFeedTask(void *argument)</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">		WDOG_Feed();</span><br><span class="line">		WDOG_Enable();</span><br><span class="line">        osDelay(100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="user-HardwareInitTask"><a href="#user-HardwareInitTask" class="headerlink" title="user_HardwareInitTask"></a>user_HardwareInitTask</h3><p>这个任务的职责非常明确且关键：完成系统中所有硬件和核心软件模块的初始化。它是一个“一次性”任务，在完成所有初始化工作后，会自己删除自己，释放占用的资源。它的优先级被设得很高，以确保在其他任何应用任务运行之前，硬件已经准备就绪。<br>任务执行流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void HardwareInitTask(void *argument)</span><br><span class="line">&#123;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">        vTaskSuspendAll();</span><br></pre></td></tr></table></figure>

<p><code>vTaskSuspendAll();</code>: 挂起（暂停）FreeRTOS 的任务调度器。这是一个保护措施，确保在初始化这种关键且不可中断的过程中，不会有其他任务突然插入执行，避免了潜在的冲突。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// RTC Wake</span><br><span class="line">if(HAL_RTCEx_SetWakeUpTimer_IT(&amp;hrtc, 2000, RTC_WAKEUPCLOCK_RTCCLK_DIV16) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">  Error_Handler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置 RTC 唤醒定时器: 设置 RTC（实时时钟）的唤醒定时器，并开启中断。这是实现低功耗睡眠后能被定时唤醒的基础。通常先初始化不依赖其他模块的基础外设（如时钟、GPIO），然后再初始化更复杂的模块。这个顺序确保了依赖关系的正确性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// usart start</span><br><span class="line">HAL_UART_Receive_DMA(&amp;huart1,(uint8_t*)HardInt_receive_str,25);</span><br><span class="line">__HAL_UART_ENABLE_IT(&amp;huart1,UART_IT_IDLE);</span><br></pre></td></tr></table></figure>

<p>启动串口接收:</p>
<p><code>HAL_UART_Receive_DMA()</code>: 以 DMA（直接内存访问）方式启动串口 1 的数据接收。数据会被自动存入<code>HardInt_receive_str</code>缓冲区。使用 DMA 可以在接收数据时不占用 CPU。</p>
<p><code>__HAL_UART_ENABLE_IT(&amp;huart1,UART_IT_IDLE)</code>: 使能串口的“空闲中断”。当串口总线上一段时间没有数据传输时，会触发这个中断，通常用来判断一帧数据是否接收完毕。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// PWM Start</span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim3,TIM_CHANNEL_3);</span><br></pre></td></tr></table></figure>

<p>启动 PWM: 启动定时器 3 的 PWM（脉冲宽度调制）功能，这里用于控制 LCD 屏幕的背光亮度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// sys delay</span><br><span class="line">delay_init();</span><br></pre></td></tr></table></figure>

<p>初始化一个自定义的延时函数库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// power</span><br><span class="line">HWInterface.Power.Init();</span><br></pre></td></tr></table></figure>

<p>初始化电源管理部分，比如 ADC 采集电池电压的相关配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// key</span><br><span class="line">Key_Port_Init();</span><br></pre></td></tr></table></figure>

<p>初始化按键所使用的 GPIO 引脚。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// sensors</span><br><span class="line">uint8_t num = 3;</span><br><span class="line">while(num &amp;&amp; HWInterface.AHT21.ConnectionError)</span><br><span class="line">&#123;</span><br><span class="line">  num--;</span><br><span class="line">  HWInterface.AHT21.ConnectionError = HWInterface.AHT21.Init();</span><br><span class="line">&#125;</span><br><span class="line">// ... (其他传感器的初始化，逻辑类似) ...</span><br></pre></td></tr></table></figure>

<p>初始化所有传感器:</p>
<p>这里的设计非常健壮。它为每个传感器的初始化提供了 3 次重试机会。</p>
<p>while(num &amp;&amp; HWInterface.AHT21.ConnectionError): 只要重试次数 num 没用完，并且传感器的连接状态 ConnectionError 仍然是错误，就继续尝试。</p>
<p>HWInterface.AHT21.Init(): 调用硬件访问层提供的传感器初始化函数。</p>
<p>这个模式被用在了温湿度(AHT21)、电子罗盘(Ecompass)、气压计(Barometer)、运动传感器(IMU)和心率传感器(HR_meter)上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// EEPROM</span><br><span class="line">EEPROM_Init();</span><br><span class="line">if(!EEPROM_Check())</span><br><span class="line">&#123;</span><br><span class="line">    // ... (从EEPROM读取上次保存的设置和步数) ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化并读取 EEPROM:</p>
<p><code>EEPROM_Init()</code>: 初始化与 EEPROM 通信的 I2C 总线。</p>
<p><code>EEPROM_Check()</code>: 检查 EEPROM 中是否有合法的标记，判断数据是否有效。</p>
<p>如果数据有效 (!EEPROM_Check()为真)，则从 EEPROM 中读取上次关机前保存的用户设置（如抬腕亮屏开关）和当天的步数，并恢复到系统变量和 MPU6050 的计步器中。这保证了用户设置和计步数据的持久化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// BLE</span><br><span class="line">HWInterface.BLE.Init();</span><br><span class="line">HWInterface.BLE.Disable();</span><br></pre></td></tr></table></figure>

<p>初始化蓝牙模块，并先将其置于禁用状态以节省功耗。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// touch</span><br><span class="line">CST816_GPIO_Init();</span><br><span class="line">CST816_RESET();</span><br></pre></td></tr></table></figure>

<p>初始化触摸屏控制器 CST816 的 GPIO 并对其进行复位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// lcd</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_Fill(0,0, LCD_W, LCD_H, BLACK);</span><br><span class="line">// ... (显示开机欢迎界面) ...</span><br><span class="line">delay_ms(1000);</span><br><span class="line">LCD_Fill(0, LCD_H/2-24, LCD_W, LCD_H/2+49, BLACK);</span><br></pre></td></tr></table></figure>

<p>初始化并显示开机动画:</p>
<p><code>LCD_Init()</code>: 初始化 LCD 屏幕控制器。</p>
<p><code>LCD_Fill(...)</code>: 对屏幕进行清屏（填充为黑色）。</p>
<p><code>LCD_ShowString(...)</code>: 在屏幕上显示 “Welcome!” 和版本号信息。</p>
<p><code>delay_ms(1000)</code>: 显示 1 秒钟。</p>
<p><code>LCD_Fill(...)</code>: 再次清空欢迎信息，为显示主 UI 做准备。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ui</span><br><span class="line">// LVGL init</span><br><span class="line">lv_init();</span><br><span class="line">lv_port_disp_init();</span><br><span class="line">lv_port_indev_init();</span><br><span class="line">ui_init();</span><br></pre></td></tr></table></figure>

<p>初始化 LVGL 图形库:</p>
<p><code>lv_init()</code>: 初始化 LVGL 库本身。</p>
<p><code>lv_port_disp_init()</code>: 初始化显示端口，即告诉 LVGL 如何将它计算好的像素点刷新到 LCD 屏幕上。</p>
<p><code>lv_port_indev_init()</code>: 初始化输入设备端口，即告诉 LVGL 如何从触摸屏或按键获取输入。</p>
<p><code>ui_init()</code>: 初始化由 UI 设计工具（如 SquareLine Studio）生成的所有 UI 页面和控件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        xTaskResumeAll();</span><br><span class="line">		vTaskDelete(NULL);</span><br><span class="line">		osDelay(500);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务结束:</p>
<p><code>xTaskResumeAll()</code>: 恢复 FreeRTOS 的任务调度器。此时，所有硬件和软件模块都已准备就绪，其他任务可以安全地开始运行了。</p>
<p><code>vTaskDelete(NULL)</code>: 删除当前任务。因为初始化工作已经全部完成，这个任务没有存在的必要了，删除它可以回收其占用的堆栈内存。</p>
<h2 id="user-RunModeTasks"><a href="#user-RunModeTasks" class="headerlink" title="user_RunModeTasks"></a>user_RunModeTasks</h2><p>这个文件包含了管理手表运行模式的核心逻辑，特别是从正常运行模式进入不同级别的低功耗模式。它是手表能够长时间续航的关键。主要包含三个部分：IdleEnterTask（进入空闲模式）、StopEnterTask（进入停止模式）和一个软件定时器回调函数 IdleTimerCallback。</p>
<h3 id="1-IdleTimerCallback-空闲定时器回调"><a href="#1-IdleTimerCallback-空闲定时器回调" class="headerlink" title="1. IdleTimerCallback() - 空闲定时器回调"></a>1. IdleTimerCallback() - 空闲定时器回调</h3><p>这个函数不是一个任务，而是一个每 100 毫秒被 RTOS 内核调用一次的软件定时器回调函数。它是所有低功耗逻辑的起点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void IdleTimerCallback(void *argument)</span><br><span class="line">&#123;</span><br><span class="line">	IdleTimerCount+=1;</span><br><span class="line">	//make sure the LightOffTime&lt;TurnOffTime</span><br><span class="line">	if(IdleTimerCount == (ui_LTimeValue*10))</span><br><span class="line">	&#123;</span><br><span class="line">		uint8_t Idlestr=0;</span><br><span class="line">		//send the Light off message</span><br><span class="line">		osMessageQueuePut(Idle_MessageQueue, &amp;Idlestr, 0, 1);</span><br><span class="line">	&#125;</span><br><span class="line">	if(IdleTimerCount == (ui_TTimeValue*10))</span><br><span class="line">	&#123;</span><br><span class="line">		uint8_t Stopstr = 1;</span><br><span class="line">		IdleTimerCount  = 0;</span><br><span class="line">		//send the Stop message</span><br><span class="line">		osMessageQueuePut(Stop_MessageQueue, &amp;Stopstr, 0, 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IdleTimerCount+=1;</code>: IdleTimerCount 是一个全局变量，每次回调（每 100ms）加 1，用于记录用户无操作的时间。当用户有任何操作（触摸、按键）时，这个计数器会被清零。</p>
<p><code>if(IdleTimerCount == (ui_LTimeValue*10))</code>: 判断无操作时间是否达到了用户设定的“自动暗屏”时间（ui_LTimeValue 是从 UI 设置界面获取的秒数）。</p>
<p><code>osMessageQueuePut(Idle_MessageQueue, &amp;Idlestr, 0, 1);</code>: 如果达到时间，就向 Idle_MessageQueue 发送一个消息，通知 IdleEnterTask 任务该执行暗屏操作了。</p>
<p><code>if(IdleTimerCount == (ui_TTimeValue*10))</code>: 判断无操作时间是否达到了用户设定的“自动休眠”时间（ui_TTimeValue）。</p>
<p><code>osMessageQueuePut(Stop_MessageQueue, &amp;Stopstr, 0, 1);</code>: 如果达到时间，就向 Stop_MessageQueue 发送一个消息，通知 StopEnterTask 任务该让系统进入深度睡眠（STOP 模式）了。</p>
<p><code>IdleTimerCount = 0;</code>: 发送消息后，将计数器清零。</p>
<h3 id="2-IdleEnterTask-空闲模式任务"><a href="#2-IdleEnterTask-空闲模式任务" class="headerlink" title="2. IdleEnterTask() - 空闲模式任务"></a>2. IdleEnterTask() - 空闲模式任务</h3><p>这个任务等待处理“空闲”和“退出空闲”的消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void IdleEnterTask(void *argument)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t Idlestr=0;</span><br><span class="line">	uint8_t IdleBreakstr=0;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		//light get dark</span><br><span class="line">		if(osMessageQueueGet(Idle_MessageQueue,&amp;Idlestr,NULL,1)==osOK)</span><br><span class="line">		&#123;</span><br><span class="line">			LCD_Set_Light(5);</span><br><span class="line">		&#125;</span><br><span class="line">		//resume light if light got dark and idle state breaked by key pressing or screen touching</span><br><span class="line">		if(osMessageQueueGet(IdleBreak_MessageQueue,&amp;IdleBreakstr,NULL,1)==osOK)</span><br><span class="line">		&#123;</span><br><span class="line">			IdleTimerCount = 0;</span><br><span class="line">			LCD_Set_Light(ui_LightSliderValue);</span><br><span class="line">		&#125;</span><br><span class="line">		osDelay(10);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if(osMessageQueueGet(Idle_MessageQueue, ...)==osOK)</code>: 尝试从 Idle_MessageQueue 获取消息。如果获取成功（由 IdleTimerCallback 发送的），说明需要进入“空闲”模式。</p>
<p><code>LCD_Set_Light(5);</code>: 将屏幕背光亮度调到很低的水平（变暗），但屏幕并未完全关闭。</p>
<p><code>if(osMessageQueueGet(IdleBreak_MessageQueue, ...)==osOK)</code>: 尝试从 IdleBreak_MessageQueue 获取消息。这个消息由按键、触摸等中断触发，表示用户进行了操作，需要“退出空闲”。</p>
<p><code>IdleTimerCount = 0;</code>: 重置空闲计时器。</p>
<p><code>LCD_Set_Light(ui_LightSliderValue);</code>: 将屏幕亮度恢复到用户设定的正常亮度。</p>
<h3 id="3-StopEnterTask-停止（休眠）模式任务"><a href="#3-StopEnterTask-停止（休眠）模式任务" class="headerlink" title="3. StopEnterTask() - 停止（休眠）模式任务"></a>3. StopEnterTask() - 停止（休眠）模式任务</h3><p>这是实现深度睡眠的核心任务，逻辑也最复杂。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">void StopEnterTask(void *argument)</span><br><span class="line">&#123;</span><br><span class="line">	// ...</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		if(osMessageQueueGet(Stop_MessageQueue,&amp;Stopstr,NULL,0)==osOK)</span><br><span class="line">		&#123;</span><br><span class="line">			/*************************** your operations before sleep***************************/</span><br><span class="line">			sleep:</span><br><span class="line">			IdleTimerCount = 0;</span><br><span class="line">			//sensors</span><br><span class="line">			//usart</span><br><span class="line">			HAL_UART_MspDeInit(&amp;huart1);</span><br><span class="line">			//lcd</span><br><span class="line">			LCD_RES_Clr();</span><br><span class="line">			LCD_Close_Light();</span><br><span class="line">			//touch</span><br><span class="line">			CST816_Sleep();</span><br><span class="line"></span><br><span class="line">			/****************************** enter wakeup operations *****************************/</span><br><span class="line">			vTaskSuspendAll();</span><br><span class="line">			WDOG_Disnable();</span><br><span class="line">			CLEAR_BIT(SysTick-&gt;CTRL, SysTick_CTRL_TICKINT_Msk);</span><br><span class="line">			HAL_PWR_EnterSTOPMode(PWR_MAINREGULATOR_ON,PWR_STOPENTRY_WFI);</span><br><span class="line"></span><br><span class="line">			//here is the sleep period</span><br><span class="line"></span><br><span class="line">			/****************************** quit wakeup operations *****************************/</span><br><span class="line">			SET_BIT(SysTick-&gt;CTRL, SysTick_CTRL_TICKINT_Msk);</span><br><span class="line">			HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq));</span><br><span class="line">			SystemClock_Config();</span><br><span class="line">			WDOG_Feed();</span><br><span class="line">			xTaskResumeAll();</span><br><span class="line"></span><br><span class="line">			/****************************** your wakeup operations *****************************/</span><br><span class="line">			// ... (唤醒后的逻辑判断) ...</span><br><span class="line">			//usart</span><br><span class="line">			HAL_UART_MspInit(&amp;huart1);</span><br><span class="line">			//lcd</span><br><span class="line">			LCD_Init();</span><br><span class="line">			LCD_Set_Light(ui_LightSliderValue);</span><br><span class="line">			//touch</span><br><span class="line">			CST816_Wakeup();</span><br><span class="line">			// ...</span><br><span class="line">		&#125;</span><br><span class="line">		osDelay(100);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if(osMessageQueueGet(Stop_MessageQueue, ...)==osOK)</code>: 等待进入 STOP 模式的消息。</p>
<p>A. 进入休眠前的准备:</p>
<p><code>sleep:</code>: 这是一个 goto 标签，用于在某些唤醒条件下立即重新进入睡眠。</p>
<p><code>HAL_UART_MspDeInit(&amp;huart1);</code>: 反初始化串口，关闭其时钟和 GPIO 以省电。</p>
<p><code>LCD_RES_Clr(); LCD_Close_Light();</code>: 关闭 LCD 屏幕电源和背光。</p>
<p><code>CST816_Sleep();</code>: 让触摸芯片进入睡眠模式。</p>
<p>B. 进入 STOP 模式:</p>
<p><code>vTaskSuspendAll();</code>: 挂起任务调度器。</p>
<p><code>WDOG_Disnable();</code>: 禁用看门狗。这是使用外部看门狗的关键优势，允许 MCU 深度睡眠而无需频繁唤醒喂狗。如果是内部看门狗，开启后无法软件关闭。</p>
<p><code>CLEAR_BIT(SysTick-&gt;CTRL, ...)</code>: 关闭 SysTick 中断。这是必须的，否则 SysTick 中断会立即唤醒 MCU。</p>
<p><code>HAL_PWR_EnterSTOPMode(...)</code>: 执行此行代码后，CPU 将停止运行，进入 STOP 模式，等待唤醒事件（WFI: Wait For Interrupt）。</p>
<p>C. 从 STOP 模式唤醒后的恢复:</p>
<p>代码执行到这里，说明一个唤醒中断（如按键、RTC、充电插入）已经发生。</p>
<p><code>SET_BIT(SysTick-&gt;CTRL, ...)</code>: 重新开启 SysTick 中断。</p>
<p><code>SystemClock_Config()</code>;: 重新配置系统时钟。因为从 STOP 模式唤醒后，系统会使用内部的 HSI 时钟，需要重新配置为高速的 HSE 时钟。</p>
<p><code>WDOG_Feed();</code>: 喂一次狗，表示系统已恢复。</p>
<p><code>xTaskResumeAll();</code>: 恢复任务调度器。</p>
<p>D. 唤醒后的业务逻辑:</p>
<p>判断唤醒源: <code>if(HWInterface.IMU.wrist_is_enabled)</code>检查是否是抬腕唤醒，<code>if(!KEY1 || KEY2 || ...)</code>检查是否是按键或充电唤醒。</p>
<p><code>goto sleep;</code>: 如果唤醒条件不满足（比如抬腕亮屏后，用户又迅速放下手腕），则使用 goto 语句直接跳回 sleep 标签，让系统立即重新进入睡眠，避免了不必要的亮屏。</p>
<p>重新初始化外设: 如果决定正常唤醒，则需要重新初始化之前关闭的外设，如 HAL_UART_MspInit, LCD_Init, CST816_Wakeup 等。</p>
<p><code>osMessageQueuePut(HomeUpdata_MessageQueue, ...)</code>: 发送消息，通知主界面更新数据（因为睡眠期间时间等信息可能已变化）。</p>
<h3 id="user-KeyTask"><a href="#user-KeyTask" class="headerlink" title="user_KeyTask"></a>user_KeyTask</h3><p>这个任务的职责非常专一：持续扫描物理按键的状态，并将按键事件通过消息队列发送给其他任务进行处理。<br>任务执行流程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void KeyTask(void *argument)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t keystr=0;</span><br><span class="line">	uint8_t Stopstr=0;</span><br><span class="line">	uint8_t IdleBreakstr=0;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		switch(KeyScan(0))</span><br><span class="line">		&#123;</span><br><span class="line">			case 1:</span><br><span class="line">				keystr = 1;</span><br><span class="line">				osMessageQueuePut(Key_MessageQueue, &amp;keystr, 0, 1);</span><br><span class="line">				osMessageQueuePut(IdleBreak_MessageQueue, &amp;IdleBreakstr, 0, 1);</span><br><span class="line">				break;</span><br><span class="line"></span><br><span class="line">			case 2:</span><br><span class="line">				if(Page_Get_NowPage()-&gt;page_obj == &amp;ui_HomePage)</span><br><span class="line">				&#123;</span><br><span class="line">					osMessageQueuePut(Stop_MessageQueue, &amp;Stopstr, 0, 1);</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">				&#123;</span><br><span class="line">					keystr = 2;</span><br><span class="line">					osMessageQueuePut(Key_MessageQueue, &amp;keystr, 0, 1);</span><br><span class="line">					osMessageQueuePut(IdleBreak_MessageQueue, &amp;IdleBreakstr, 0, 1);</span><br><span class="line">				&#125;</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">		osDelay(1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>osMessageQueuePut(Key_MessageQueue, &amp;keystr, 0, 1);</code>: 将按键消息 1 发送到 Key_MessageQueue。ScrRenewTask（屏幕刷新任务）会接收这个消息来执行相应的页面切换。</p>
<p><code>osMessageQueuePut(IdleBreak_MessageQueue, &amp;IdleBreakstr, 0, 1);</code>: 同时，向 IdleBreak_MessageQueue 发送一个“空闲中断”消息。这非常重要，它告诉 IdleEnterTask 任务：“用户有操作了”，从而重置空闲计时器并点亮屏幕。</p>
<p><code>if(Page_Get_NowPage()-&gt;page_obj == &amp;ui_HomePage)</code>: 判断当前是否在主界面。</p>
<p><code>osMessageQueuePut(Stop_MessageQueue, &amp;Stopstr, 0, 1);</code>: 如果在主界面，那么这个按键的功能就是“锁屏&#x2F;休眠”。它直接向 Stop_MessageQueue 发送消息，通知 StopEnterTask 任务让系统进入 STOP 模式。</p>
<p>如果不在主界面。</p>
<p><code>osMessageQueuePut(Key_MessageQueue, &amp;keystr, 0, 1);</code>: 将按键消息 2 发送到 Key_MessageQueue，ScrRenewTask 会接收它并执行“返回上一页”的操作。</p>
<p><code>osMessageQueuePut(IdleBreak_MessageQueue, &amp;IdleBreakstr, 0, 1);</code>: 同样，发送“空闲中断”消息来点亮屏幕和重置计时器。</p>
<p><code>osDelay(1);</code>: 每次循环后延时 1 毫秒。这可以防止任务 100%占用 CPU，让其他任务也有机会运行。同时也起到了按键消抖的作用。</p>
<h3 id="user-ScrRenewTask"><a href="#user-ScrRenewTask" class="headerlink" title="user_ScrRenewTask"></a>user_ScrRenewTask</h3><p>这个任务的角色是按键事件的响应者和 UI 页面导航的执行者。它专门等待从 Key_MessageQueue 中传来的消息，并根据消息内容调用 PageManager 提供的函数来更新屏幕显示。</p>
<p>任务执行流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void ScrRenewTask(void *argument)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t keystr=0;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		if(osMessageQueueGet(Key_MessageQueue,&amp;keystr,NULL,0)==osOK)</span><br><span class="line">		&#123;</span><br><span class="line">			//key1 pressed</span><br><span class="line">			if(keystr == 1)</span><br><span class="line">			&#123;</span><br><span class="line">				Page_Back();</span><br><span class="line">				if(Page_Get_NowPage()-&gt;page_obj == &amp;ui_MenuPage)</span><br><span class="line">				&#123;</span><br><span class="line">					//HR sensor sleep</span><br><span class="line">					EM7028_hrs_DisEnable();</span><br><span class="line">					//sensor sleep</span><br><span class="line">					LSM303DLH_Sleep();</span><br><span class="line">					// SPL_Sleep();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//key2 pressed</span><br><span class="line">			else if(keystr == 2)</span><br><span class="line">			&#123;</span><br><span class="line">				Page_Back_Bottom();</span><br><span class="line">				//HR sensor sleep</span><br><span class="line">				EM7028_hrs_DisEnable();</span><br><span class="line">  				//sensor sleep</span><br><span class="line">				LSM303DLH_Sleep();</span><br><span class="line">				// SPL_Sleep();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		osDelay(10);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uint8_t keystr=0;</code>: 定义一个局部变量，用于存储从消息队列中接收到的按键值。</p>
<p><code>if(osMessageQueueGet(Key_MessageQueue, &amp;keystr, NULL, 0) == osOK)</code>: 这是任务的核心。它尝试从<code>Key_MessageQueue</code>获取一个消息。</p>
<p><code>NULL, 0</code>: 表示如果队列中没有消息，任务不会被阻塞，会立刻向下执行。</p>
<p><code>== osOK</code>: 判断是否成功获取到了消息。</p>
<p><code>Page_Back();</code>: 调用页面管理器的“返回上一页”函数。</p>
<p><code>if(Page_Get_NowPage()-&gt;page_obj == &amp;ui_MenuPage)</code>: 检查返回后，当前页面是否是菜单页。</p>
<p><code>EM7028_hrs_DisEnable(); ...</code>: 如果是，则调用一系列函数让心率、电子罗盘等传感器进入睡眠模式，以节省电量。这是一种优化，因为在菜单页通常不需要这些传感器工作。</p>
<p><code>Page_Back_Bottom();</code>: 调用页面管理器的“直接返回到最底部的页面（主页）”函数。</p>
<p><code>EM7028_hrs_DisEnable(); ...</code>: 同样，在返回主页后，也让所有非必要的传感器进入睡眠模式。</p>
<p><code>osDelay(10);</code>: 每次循环延时 10 毫秒，释放 CPU 给其他任务。</p>
<p>这个任务清晰地展示了任务间协作的模式：KeyTask 作为生产者，ScrRenewTask 作为消费者，通过 Key_MessageQueue 这个“管道”解耦了按键检测和 UI 响应，使得代码结构更加清晰。</p>
<h3 id="user-ChargCheckTask"><a href="#user-ChargCheckTask" class="headerlink" title="user_ChargCheckTask"></a>user_ChargCheckTask</h3><p>这个任务专门负责处理与充电相关的逻辑。它通过一个硬件中断标志位来被动触发，而不是持续轮询，这是一种高效的设计。</p>
<p>任务执行流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void ChargPageEnterTask(void *argument)</span><br><span class="line">&#123;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		// 硬件中断发生</span><br><span class="line">		if(HardInt_Charg_flag)</span><br><span class="line">		&#123;</span><br><span class="line">			IdleTimerCount = 0;</span><br><span class="line">			HardInt_Charg_flag = 0;</span><br><span class="line">			if((ChargeCheck()) &amp;&amp; (Page_Get_NowPage()-&gt;page_obj != &amp;ui_ChargPage))</span><br><span class="line">			&#123;</span><br><span class="line">				Page_Load(&amp;Page_Charg);</span><br><span class="line">			&#125;</span><br><span class="line">			else if((!ChargeCheck()) &amp;&amp; (Page_Get_NowPage()-&gt;page_obj == &amp;ui_ChargPage))</span><br><span class="line">			&#123;</span><br><span class="line">				Page_Back();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		osDelay(500);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if(HardInt_Charg_flag)</code>: 这是任务的核心触发条件。<code>HardInt_Charg_flag</code>是一个全局标志位，它应该在一个 GPIO 的外部中断服务程序（ISR）中被设置为 1。这个中断引脚连接到充电检测电路上。当用户插入或拔下充电器时，电平变化触发中断，从而“唤醒”这个任务。</p>
<p><code>IdleTimerCount = 0;</code>: 只要检测到充电状态变化，就重置空闲计时器，防止手表在充电时自动休眠。</p>
<p><code>HardInt_Charg_flag = 0</code>;: 处理中断后，立即清除标志位，为下一次中断做准备。这是一个必须的步骤。</p>
<p><code>if((ChargeCheck()) &amp;&amp; (Page_Get_NowPage()-&gt;page_obj != &amp;ui_ChargPage))</code>:</p>
<p><code>ChargeCheck()</code>: 调用一个底层函数来再次确认当前是否确实在充电。</p>
<p><code>Page_Get_NowPage()-&gt;page_obj != &amp;ui_ChargPage</code>: 检查当前是否不在充电页面。</p>
<p>如果“正在充电”且“不在充电页面”，则执行：</p>
<p><code>Page_Load(&amp;Page_Charg);</code>: 调用页面管理器，加载并显示充电页面。</p>
<p><code>else if((!ChargeCheck()) &amp;&amp; (Page_Get_NowPage()-&gt;page_obj == &amp;ui_ChargPage))</code>:</p>
<p><code>!ChargeCheck()</code>: 判断当前是否没有在充电（比如用户拔掉了充电器）。</p>
<p><code>Page_Get_NowPage()-&gt;page_obj == &amp;ui_ChargPage</code>: 检查当前是否正好在充电页面。</p>
<p>如果“未在充电”且“在充电页面”，则执行：</p>
<p><code>Page_Back();</code>: 调用页面管理器，从充电页面返回到之前的页面。</p>
<p><code>osDelay(500);</code>: 任务每 500 毫秒检查一次标志位。这个延时决定了响应充电事件的最大延迟。</p>
<h3 id="user-MessageSendTask"><a href="#user-MessageSendTask" class="headerlink" title="user_MessageSendTask"></a>user_MessageSendTask</h3><p>这个任务是手表与外界（如手机蓝牙助手）进行数据交换的窗口。它负责解析收到的命令字符串，并根据命令执行相应的操作，比如设置时间、返回手表状态等。</p>
<p>全局变量与辅助函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">	// ... (成员变量) ...</span><br><span class="line">&#125;BLEMessage;</span><br><span class="line"></span><br><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">	// ... (成员变量) ...</span><br><span class="line">&#125;TimeSetMessage;</span><br></pre></td></tr></table></figure>

<p>定义了两个结构体<code>BLEMessage</code>和<code>TimeSetMessage</code>，用于临时存储要发送的数据或从字符串中解析出的数据，让代码更具可读性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void StrCMD_Get(uint8_t * str,uint8_t * cmd)</span><br><span class="line">&#123;</span><br><span class="line">	// ... (从 &quot;CMD=DATA&quot; 格式的字符串中提取出 &quot;CMD&quot; 部分) ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8_t TimeFormat_Get(uint8_t * str)</span><br><span class="line">&#123;</span><br><span class="line">	// ... (从 &quot;OV+ST=20230629125555&quot; 格式的字符串中解析出年月日时分秒) ...</span><br><span class="line">	// ... (并调用RTC函数设置系统时间) ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>StrCMD_Get</code>: 一个辅助函数，用于从接收到的字符串（如”CMD&#x3D;DATA”）中提取出等号前面的命令部分（”CMD”）。</p>
<p><code>TimeFormat_Get</code>: 一个辅助函数，专门用于解析设置时间的命令字符串，并将解析出的数字设置到 RTC 中。它还包含数据合法性检查。</p>
<p><code>MessageSendTask()</code>- 任务主函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void MessageSendTask(void *argument)</span><br><span class="line">&#123;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		if(HardInt_uart_flag)</span><br><span class="line">		&#123;</span><br><span class="line">			HardInt_uart_flag = 0;</span><br><span class="line">			uint8_t IdleBreakstr = 0;</span><br><span class="line">			osMessageQueuePut(IdleBreak_MessageQueue,&amp;IdleBreakstr,NULL,1);</span><br><span class="line">			printf(&quot;RecStr:%s\r\n&quot;,HardInt_receive_str);</span><br></pre></td></tr></table></figure>

<p><code>if(HardInt_uart_flag)</code>: 和充电任务类似，它由一个全局中断标志位 HardInt_uart_flag 触发。这个标志位在串口空闲中断（IDLE_IT）的服务程序中被设置，表示一帧数据已经通过 DMA 完整接收到<code>HardInt_receive_str</code>缓冲区中。</p>
<p><code>HardInt_uart_flag = 0;</code>: 清除标志位。</p>
<p><code>osMessageQueuePut(IdleBreak_MessageQueue, ...)</code>: 任何串口通信都视为用户活动，发送消息以打断空闲状态。</p>
<p><code>printf(&quot;RecStr:%s\r\n&quot;,HardInt_receive_str);</code>: 通过 printf（重定向到串口）将收到的原始字符串回显，方便调试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if(!strcmp(HardInt_receive_str,&quot;OV&quot;))</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;OK\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if(!strcmp(HardInt_receive_str,&quot;OV+VERSION&quot;))</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;VERSION=V%d.%d.%d\r\n&quot;, ...);</span><br><span class="line">&#125;</span><br><span class="line">else if(!strcmp(HardInt_receive_str,&quot;OV+SEND&quot;))</span><br><span class="line">&#123;</span><br><span class="line">             // ... (从各个硬件接口获取当前状态数据) ...</span><br><span class="line">	// ... (通过printf格式化输出所有数据) ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命令解析: 使用 strcmp 函数（字符串比较）来判断收到的命令是什么。</p>
<p>“OV”: 这是一个“连接测试”命令，收到后回复”OK\r\n”。</p>
<p>“OV+VERSION”: 查询版本号命令，回复格式化的版本号字符串。</p>
<p>“OV+SEND”: 请求手表当前所有状态数据的命令。代码会从 RTC、HWInterface 等处获取时间、温湿度、心率、血氧、步数等信息，然后通过一系列 printf 发送出去。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//set time//OV+ST=20230629125555</span><br><span class="line">else if(strlen(HardInt_receive_str)==20)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t cmd[10];</span><br><span class="line">	memset(cmd,0,sizeof(cmd));</span><br><span class="line">	StrCMD_Get(HardInt_receive_str,cmd);</span><br><span class="line">	if(ui_APPSy_EN &amp;&amp; !strcmp(cmd,&quot;OV+ST&quot;))</span><br><span class="line">	&#123;</span><br><span class="line">		TimeFormat_Get(HardInt_receive_str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置时间命令解析:</p>
<p><code>if(strlen(HardInt_receive_str)==20)</code>: 通过判断字符串长度（20 个字符）来快速识别这可能是一个设置时间的命令。</p>
<p><code>StrCMD_Get(...)</code>: 调用辅助函数提取命令部分。</p>
<p><code>if(ui_APPSy_EN &amp;&amp; !strcmp(cmd,&quot;OV+ST&quot;))</code>: 检查“允许 APP 同步”的开关（ui_APPSy_EN）是否打开，并且命令是否是”OV+ST”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TimeFormat_Get(HardInt_receive_str);: 如果条件都满足，则调用时间解析函数来完成时间设置。</span><br><span class="line"></span><br><span class="line">			memset(HardInt_receive_str,0,sizeof(HardInt_receive_str));</span><br><span class="line">		&#125;</span><br><span class="line">		osDelay(1000);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>memset(...)</code>: 在处理完一次命令后，清空接收缓冲区，为下一次接收做准备。</p>
<p><code>osDelay(1000);</code>: 如果没有中断标志，任务会在此延时 1 秒，CPU 占用率很低。</p>
<h3 id="user-SensUpdateTask"><a href="#user-SensUpdateTask" class="headerlink" title="user_SensUpdateTask"></a>user_SensUpdateTask</h3><p>这个文件是手表的“感知中心”，负责从各种传感器收集原始数据，进行处理，并更新到系统的全局数据接口（HWInterface）中，供 UI 或其他任务使用。它包含了三个独立的任务：MPUCheckTask, HRDataUpdateTask, 和 SensorDataUpdateTask。</p>
<p><code>MPUCheckTask()</code> - MPU6050 状态检查任务 (抬腕检测)<br>这个任务专门用于实现“抬腕亮屏”和“放腕息屏”的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void MPUCheckTask(void *argument)</span><br><span class="line">&#123;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		if(HWInterface.IMU.wrist_is_enabled)</span><br><span class="line">		&#123;</span><br><span class="line">			if(MPU_isHorizontal())</span><br><span class="line">			&#123;</span><br><span class="line">				HWInterface.IMU.wrist_state = WRIST_UP;</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				if(WRIST_UP == HWInterface.IMU.wrist_state)</span><br><span class="line">				&#123;</span><br><span class="line">					HWInterface.IMU.wrist_state = WRIST_DOWN;</span><br><span class="line">					if( Page_Get_NowPage()-&gt;page_obj == &amp;ui_HomePage ||</span><br><span class="line">						Page_Get_NowPage()-&gt;page_obj == &amp;ui_MenuPage ||</span><br><span class="line">						Page_Get_NowPage()-&gt;page_obj == &amp;ui_SetPage )</span><br><span class="line">					&#123;</span><br><span class="line">						uint8_t Stopstr;</span><br><span class="line">						osMessageQueuePut(Stop_MessageQueue, &amp;Stopstr, 0, 1);//sleep</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				HWInterface.IMU.wrist_state = WRIST_DOWN;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		osDelay(300);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if(HWInterface.IMU.wrist_is_enabled)</code>: 首先检查用户是否在设置中开启了“抬腕亮屏”功能。如果没开启，任务将不执行任何操作。</p>
<p><code>if(MPU_isHorizontal())</code>: 调用 MPU6050 驱动中的函数，判断手表当前是否处于水平状态。</p>
<p><code>HWInterface.IMU.wrist_state = WRIST_UP;</code>: 如果是水平的，就将手腕状态标记为 WRIST_UP（抬起）。</p>
<p><code>if(WRIST_UP == HWInterface.IMU.wrist_state)</code>: 判断上一个状态是否是 WRIST_UP。这个判断非常关键，它确保了只有在“从抬起到放下”这个瞬间才会执行息屏逻辑。</p>
<p><code>HWInterface.IMU.wrist_state = WRIST_DOWN;</code>: 将当前状态更新为 WRIST_DOWN。</p>
<p><code>if( Page_Get_NowPage()-&gt;page_obj == ... )</code>: 检查当前是否在主页、菜单页或设置页。只有在这些非运动、非专注模式的页面下，放下手腕才会触发息屏。</p>
<p><code>osMessageQueuePut(Stop_MessageQueue, ...)</code>: 发送消息，通知 StopEnterTask 让系统进入休眠。</p>
<p><code>osDelay(300);</code>: 每 300 毫秒检查一次手腕状态。</p>
<p><code>HRDataUpdateTask()</code> - 心率数据更新任务<br>这个任务专门负责在心率测量页面持续读取和计算心率值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void HRDataUpdateTask(void *argument)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t IdleBreakstr=0;</span><br><span class="line">	uint16_t dat=0;</span><br><span class="line">	uint8_t hr_temp=0;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		if(Page_Get_NowPage()-&gt;page_obj == &amp;ui_HRPage)</span><br><span class="line">		&#123;</span><br><span class="line">			osMessageQueuePut(IdleBreak_MessageQueue, &amp;IdleBreakstr, 0, 1);</span><br><span class="line">			//sensor wake up</span><br><span class="line">			EM7028_hrs_Enable();</span><br><span class="line">			if(!HWInterface.HR_meter.ConnectionError)</span><br><span class="line">			&#123;</span><br><span class="line">				//Hr messure</span><br><span class="line">				vTaskSuspendAll();</span><br><span class="line">				hr_temp = HR_Calculate(EM7028_Get_HRS1(),user_HR_timecount);</span><br><span class="line">				xTaskResumeAll();</span><br><span class="line">				if(HWInterface.HR_meter.HrRate != hr_temp &amp;&amp; hr_temp&gt;50 &amp;&amp; hr_temp&lt;120)</span><br><span class="line">				&#123;</span><br><span class="line">					HWInterface.HR_meter.HrRate = hr_temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		osDelay(50);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if(Page_Get_NowPage()-&gt;page_obj == &amp;ui_HRPage)</code>: 任务的核心逻辑只有在用户进入了心率页面时才会被激活。这是一种非常高效的节能策略。</p>
<p><code>osMessageQueuePut(IdleBreak_MessageQueue, ...)</code>: 只要在心率页面，就持续发送“空闲中断”消息，防止手表自动息屏。</p>
<p><code>EM7028_hrs_Enable();</code>: 唤醒心率传感器。</p>
<p><code>if(!HWInterface.HR_meter.ConnectionError)</code>: 检查心率传感器是否连接正常。</p>
<p><code>vTaskSuspendAll(); ... xTaskResumeAll();</code>: 在调用心率计算函数 HR_Calculate 前后，挂起和恢复任务调度器。这可能是为了保证读取传感器原始值和时间戳 user_HR_timecount 的原子性。</p>
<p><code>hr_temp = HR_Calculate(...)</code>: 调用心率计算算法，传入从传感器读到的原始值和计时器值，得到计算后的心率。</p>
<p><code>if( ... &amp;&amp; hr_temp&gt;50 &amp;&amp; hr_temp&lt;120)</code>: 对计算结果进行合理性检查，过滤掉明显的异常值。</p>
<p><code>HWInterface.HR_meter.HrRate = hr_temp</code>;: 将有效的心率值更新到全局硬件接口中，UI 会自动从这里读取并显示。</p>
<p><code>osDelay(50);</code>: 每 50 毫秒进行一次心率计算和更新。</p>
<p><code>SensorDataUpdateTask()</code> - 通用传感器数据更新任务<br>这是一个综合性的任务，负责处理多种场景下的传感器数据更新。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void SensorDataUpdateTask(void *argument)</span><br><span class="line">&#123;</span><br><span class="line">	// ...</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		// Update the sens data showed in Home</span><br><span class="line">		uint8_t HomeUpdataStr;</span><br><span class="line">		if(osMessageQueueGet(HomeUpdata_MessageQueue, &amp;HomeUpdataStr, NULL, 0)==osOK)</span><br><span class="line">		&#123;</span><br><span class="line">            // ... (计算电量、获取步数、温湿度) ...</span><br><span class="line">			//send data save message queue</span><br><span class="line">			uint8_t Datastr = 3;</span><br><span class="line">			osMessageQueuePut(DataSave_MessageQueue, &amp;Datastr, 0, 1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// SPO2 Page</span><br><span class="line">		if(Page_Get_NowPage()-&gt;page_obj == &amp;ui_SPO2Page)</span><br><span class="line">		&#123;</span><br><span class="line">			// ... (血氧测量逻辑) ...</span><br><span class="line">		&#125;</span><br><span class="line">		// Env Page</span><br><span class="line">		else if(Page_Get_NowPage()-&gt;page_obj == &amp;ui_EnvPage)</span><br><span class="line">		&#123;</span><br><span class="line">			// ... (环境温湿度测量逻辑) ...</span><br><span class="line">		&#125;</span><br><span class="line">		// Compass page</span><br><span class="line">		else if(Page_Get_NowPage()-&gt;page_obj == &amp;ui_CompassPage)</span><br><span class="line">		&#123;</span><br><span class="line">			// ... (电子罗盘和气压计测量逻辑) ...</span><br><span class="line">		&#125;</span><br><span class="line">		osDelay(500);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if(osMessageQueueGet(HomeUpdata_MessageQueue, ...)==osOK)</code>: 场景一：更新主页数据。</p>
<p>这个任务会等待 HomeUpdata_MessageQueue 的消息。这个消息在系统刚唤醒或需要强制刷新数据时被发送。</p>
<p>收到消息后，它会执行一系列数据更新操作：</p>
<p><code>HWInterface.Power.BatCalculate()</code>: 计算电池剩余电量。</p>
<p><code>HWInterface.IMU.GetSteps()</code>: 获取当前的总步数。</p>
<p><code>HWInterface.AHT21.GetHumiTemp(...)</code>: 获取温湿度。</p>
<p><code>osMessageQueuePut(DataSave_MessageQueue, ...)</code>: 在更新完主页数据后，发送一个消息给 DataSaveTask，通知它将最新的步数等信息保存到 EEPROM 中。</p>
<p><code>if(Page_Get_NowPage()-&gt;page_obj == &amp;ui_SPO2Page)</code>: 如果在血氧页面，执行血氧测量逻辑。</p>
<p><code>else if(Page_Get_NowPage()-&gt;page_obj == &amp;ui_EnvPage)</code>: 如果在环境页面，执行温湿度测量逻辑。</p>
<p><code>else if(Page_Get_NowPage()-&gt;page_obj == &amp;ui_CompassPage)</code>: 如果在罗盘页面，则唤醒并读取电子罗盘和气压计的数据。</p>
<p>这个文件的设计充分体现了按需更新和节能的思想。大部分传感器的耗电行为都与当前 UI 页面绑定，只有在需要显示该数据时，对应的任务逻辑才会被激活，从而最大限度地延长了电池续航。</p>
<h3 id="user-DataSaveTask"><a href="#user-DataSaveTask" class="headerlink" title="user_DataSaveTask"></a>user_DataSaveTask</h3><p>这个任务的职责是将重要的用户数据和设置写入到 EEPROM 中，以实现断电后数据不丢失（持久化存储）。它是一个消费者任务，专门等待来自其他任务的“保存数据”请求。</p>
<p>EEPROM 数据结构说明<br>在代码注释中，清晰地说明了 EEPROM 中存储的数据格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/******************************************</span><br><span class="line">EEPROM Data description:</span><br><span class="line">[0x00]:0x55 for check</span><br><span class="line">[0x01]:0xAA for check</span><br><span class="line"></span><br><span class="line">[0x10]:user wrist setting, HWInterface.IMU.wrist_is_enabled</span><br><span class="line">[0x11]:user ui_APPSy_EN setting</span><br><span class="line"></span><br><span class="line">[0x20]:Last Save Day(0-31)</span><br><span class="line">[0x21]:Day Steps</span><br><span class="line"></span><br><span class="line">*******************************************/</span><br></pre></td></tr></table></figure>

<p><code>0x00</code>, <code>0x01</code>: 存储固定的校验码 0x55AA，用于上电时判断 EEPROM 中的数据是否有效。</p>
<p><code>0x10</code>: 存储“抬腕亮屏”功能的开关状态。</p>
<p><code>0x11</code>: 存储“允许 APP 同步”功能的开关状态。</p>
<p><code>0x20</code>: 存储上一次保存数据时的日期（几号）。</p>
<p><code>0x21</code>, <code>0x22</code>: 存储当天的总步数（一个 16 位的数，需要两个字节）。</p>
<p>任务执行流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void DataSaveTask(void *argument)</span><br><span class="line">&#123;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		uint8_t Datastr=0;</span><br><span class="line">		if(osMessageQueueGet(DataSave_MessageQueue,&amp;Datastr,NULL,1)==osOK)</span><br><span class="line">		&#123;</span><br><span class="line">			/****************</span><br><span class="line">			Setting change</span><br><span class="line">			date change</span><br><span class="line">			Step change</span><br><span class="line">			****************/</span><br><span class="line">			uint8_t dat[3];</span><br><span class="line">			dat[0] = HWInterface.IMU.wrist_is_enabled;</span><br><span class="line">			dat[1] = ui_APPSy_EN;</span><br><span class="line">			SettingSave(dat,0x10,2);</span><br><span class="line"></span><br><span class="line">			RTC_DateTypeDef nowdate;</span><br><span class="line">			HAL_RTC_GetDate(&amp;hrtc,&amp;nowdate,RTC_FORMAT_BIN);</span><br><span class="line"></span><br><span class="line">			SettingGet(dat,0x20,3);</span><br><span class="line">			if(dat[0] != nowdate.Date)</span><br><span class="line">			&#123;</span><br><span class="line">				if(!HWInterface.IMU.ConnectionError)</span><br><span class="line">					HWInterface.IMU.SetSteps(0);</span><br><span class="line"></span><br><span class="line">				dat[0] = nowdate.Date;</span><br><span class="line">				dat[2] = 0;</span><br><span class="line">				dat[1] = 0;</span><br><span class="line">				SettingSave(dat,0x20,3);</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				uint16_t temp = HWInterface.IMU.GetSteps();</span><br><span class="line">				dat[0] = nowdate.Date;</span><br><span class="line">				dat[2] = temp &amp; 0xff;</span><br><span class="line">				dat[1] = temp&gt;&gt;8 &amp; 0xff;</span><br><span class="line">				SettingSave(dat,0x20,3);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		osDelay(100);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if(osMessageQueueGet(DataSave_MessageQueue, ...)==osOK)</code>: 任务的核心，等待从<code>DataSave_MessageQueue</code>中获取消息。这个消息由 SensorDataUpdateTask 在更新完主页数据后发送。</p>
<p>保存用户设置:</p>
<p><code>dat[0] = HWInterface.IMU.wrist_is_enabled;</code>: 从硬件接口获取“抬腕亮屏”的当前设置。</p>
<p><code>dat[1] = ui_APPSy_EN;</code>: 获取“允许 APP 同步”的当前设置。</p>
<p><code>SettingSave(dat, 0x10, 2);</code>: 调用底层的 EEPROM 写入函数，将这两个字节的设置数据写入到从地址<code>0x10</code>开始的位置。</p>
<p>保存步数（包含日期切换逻辑）:</p>
<p><code>HAL_RTC_GetDate(&amp;hrtc, &amp;nowdate, RTC_FORMAT_BIN);</code>: 获取当前的日期。</p>
<p><code>SettingGet(dat, 0x20, 3);</code>: 从 EEPROM 中读出上次保存的日期和步数。</p>
<p><code>if(dat[0] != nowdate.Date)</code>: 判断日期是否发生了变化（即是否进入了新的一天）。</p>
<p>如果日期变了（新的一天开始了）：</p>
<p><code>HWInterface.IMU.SetSteps(0);</code>: 将 MPU6050 内部的计步器清零。</p>
<p><code>dat[0] = nowdate.Date; dat[1]=0; dat[2]=0;</code>: 准备要写入 EEPROM 的新数据：今天的日期和清零后的步数。</p>
<p><code>SettingSave(dat, 0x20, 3);</code>: 将新数据写入 EEPROM。</p>
<p>如果日期没变（还是今天）。</p>
<p><code>uint16_t temp = HWInterface.IMU.GetSteps();</code>: 获取当前的最新步数。</p>
<p><code>dat[0] = nowdate.Date;</code> …: 准备要写入的数据：今天的日期和最新的步数。</p>
<p><code>SettingSave(dat, 0x20, 3);</code>: 将最新的步数更新到 EEPROM 中。</p>
<p><code>osDelay(100);</code>: 如果没有消息，任务延时 100 毫秒。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A4%8D%E5%88%BB/" rel="tag"># 复刻</a>
              <a href="/tags/STM32/" rel="tag"># STM32</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/08/04/RTOS/" rel="prev" title="RTOS学习笔记（From尚硅谷）">
      <i class="fa fa-chevron-left"></i> RTOS学习笔记（From尚硅谷）
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/08/17/LVGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="LVGL学习笔记">
      LVGL学习笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6"><span class="nav-number">1.</span> <span class="nav-text">整体框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">硬件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90"><span class="nav-number">1.1.1.</span> <span class="nav-text">系统组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9B%E7%94%B5%E9%83%A8%E5%88%86"><span class="nav-number">1.1.2.</span> <span class="nav-text">供电部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%85%E7%94%B5%E9%83%A8%E5%88%86"><span class="nav-number">1.1.3.</span> <span class="nav-text">充电部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I2C-%E6%80%BB%E7%BA%BF"><span class="nav-number">1.1.4.</span> <span class="nav-text">I2C 总线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MPU-6050"><span class="nav-number">1.1.5.</span> <span class="nav-text">MPU-6050</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPL06-001-%E6%95%B0%E5%AD%97%E6%B0%94%E5%8E%8B%E4%BC%A0%E6%84%9F%E5%99%A8"><span class="nav-number">1.1.6.</span> <span class="nav-text">SPL06-001 数字气压传感器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AHT21B-%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8"><span class="nav-number">1.1.7.</span> <span class="nav-text">AHT21B 温湿度传感器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LSM303DLHC-%E6%8C%87%E5%8D%97%E9%92%88%E6%A8%A1%E5%9D%97"><span class="nav-number">1.1.8.</span> <span class="nav-text">LSM303DLHC 指南针模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EM7028-%E5%BF%83%E7%8E%87%E6%A3%80%E6%B5%8B"><span class="nav-number">1.1.9.</span> <span class="nav-text">EM7028 心率检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%93%9D%E7%89%99"><span class="nav-number">1.1.10.</span> <span class="nav-text">蓝牙</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STM32F411CEU6"><span class="nav-number">1.1.11.</span> <span class="nav-text">STM32F411CEU6</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9B%E7%94%B5%E9%83%A8%E5%88%86-1"><span class="nav-number">1.1.12.</span> <span class="nav-text">供电部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%85%E7%94%B5%E9%83%A8%E5%88%86-1"><span class="nav-number">1.1.13.</span> <span class="nav-text">充电部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EEPROM-%E5%92%8C%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="nav-number">1.1.14.</span> <span class="nav-text">EEPROM 和看门狗</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6"><span class="nav-number">1.2.</span> <span class="nav-text">软件框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MDK-%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">MDK 工程结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CubeMX-%E6%A1%86%E6%9E%B6"><span class="nav-number">1.2.2.</span> <span class="nav-text">CubeMX 框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%BF%E8%BD%BD%E9%A9%B1%E5%8A%A8-BSP"><span class="nav-number">1.2.3.</span> <span class="nav-text">板载驱动 BSP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9C%BA%E5%88%B6-HWDataAccess"><span class="nav-number">1.2.4.</span> <span class="nav-text">硬件访问机制-HWDataAccess</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LVGL-%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86-PageManager"><span class="nav-number">1.2.5.</span> <span class="nav-text">LVGL 页面管理-PageManager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.2.6.</span> <span class="nav-text">多线程任务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UI-%E4%B8%8E%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86-LVGL-PageManager"><span class="nav-number">2.</span> <span class="nav-text">UI 与页面管理 (LVGL &amp; PageManager)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%BB%E5%8A%A1-FreeRTOS-Tasks"><span class="nav-number">3.</span> <span class="nav-text">多线程任务 (FreeRTOS Tasks)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#user-Taskslnit"><span class="nav-number">3.1.</span> <span class="nav-text">user_Taskslnit</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%8F%A5%E6%9F%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.1.1.</span> <span class="nav-text">任务句柄定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9A%E4%B9%89"><span class="nav-number">3.1.2.</span> <span class="nav-text">消息队列定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#User-Tasks-Init-%E6%80%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.3.</span> <span class="nav-text">User_Tasks_Init() - 总初始化函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TaskTickHook-%E7%B3%BB%E7%BB%9F%E8%8A%82%E6%8B%8D%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.4.</span> <span class="nav-text">TaskTickHook() - 系统节拍钩子函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LvHandlerTask-%E5%92%8C-WDOGFeedTask"><span class="nav-number">3.1.5.</span> <span class="nav-text">LvHandlerTask() 和 WDOGFeedTask()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#user-HardwareInitTask"><span class="nav-number">3.1.6.</span> <span class="nav-text">user_HardwareInitTask</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#user-RunModeTasks"><span class="nav-number">3.2.</span> <span class="nav-text">user_RunModeTasks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-IdleTimerCallback-%E7%A9%BA%E9%97%B2%E5%AE%9A%E6%97%B6%E5%99%A8%E5%9B%9E%E8%B0%83"><span class="nav-number">3.2.1.</span> <span class="nav-text">1. IdleTimerCallback() - 空闲定时器回调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-IdleEnterTask-%E7%A9%BA%E9%97%B2%E6%A8%A1%E5%BC%8F%E4%BB%BB%E5%8A%A1"><span class="nav-number">3.2.2.</span> <span class="nav-text">2. IdleEnterTask() - 空闲模式任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-StopEnterTask-%E5%81%9C%E6%AD%A2%EF%BC%88%E4%BC%91%E7%9C%A0%EF%BC%89%E6%A8%A1%E5%BC%8F%E4%BB%BB%E5%8A%A1"><span class="nav-number">3.2.3.</span> <span class="nav-text">3. StopEnterTask() - 停止（休眠）模式任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#user-KeyTask"><span class="nav-number">3.2.4.</span> <span class="nav-text">user_KeyTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#user-ScrRenewTask"><span class="nav-number">3.2.5.</span> <span class="nav-text">user_ScrRenewTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#user-ChargCheckTask"><span class="nav-number">3.2.6.</span> <span class="nav-text">user_ChargCheckTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#user-MessageSendTask"><span class="nav-number">3.2.7.</span> <span class="nav-text">user_MessageSendTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#user-SensUpdateTask"><span class="nav-number">3.2.8.</span> <span class="nav-text">user_SensUpdateTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#user-DataSaveTask"><span class="nav-number">3.2.9.</span> <span class="nav-text">user_DataSaveTask</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CYZ"
      src="/images/chino2.jpg">
  <p class="site-author-name" itemprop="name">CYZ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/CYZ2024" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;CYZ2024" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/241180180@smail.nju.edu.cn" title="E-Mail → 241180180@smail.nju.edu.cn"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CYZ</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
